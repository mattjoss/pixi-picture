{"version":3,"file":"pixi-picture.js","sourceRoot":"","sources":["../src/PictureShader.ts","../src/ColorBurnShader.ts","../src/ColorDodgeShader.ts","../src/ColorShader.ts","../src/DarkenShader.ts","../src/DifferenceShader.ts","../src/FilterManagerMixin.ts","../src/HardLightShader.ts","../src/HueShader.ts","../src/LightenShader.ts","../src/LinearBurnShader.ts","../src/LinearDodgeShader.ts","../src/LinearLightShader.ts","../src/LuminosityShader.ts","../src/mapFilterBlendModesToPixi.ts","../src/NormalShader.ts","../src/OverlayShader.ts","../src/PictureRenderer.ts","../src/SaturationShader.ts","../src/SoftLightShader.ts","../src/Sprite.ts","../src/TilingSprite.ts","../src/VividLightShader.ts","../src/xporter.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,IAAU,YAAY,CAoFrB;AApFD,WAAU,YAAY;IAQlB,IAAM,SAAS,GAAe;QAC1B;YACI,YAAY,EAAE,EAAE;YAChB,QAAQ,EAAE,gCAAgC;YAC1C,YAAY,EAAE,6BAA6B;YAC3C,QAAQ,EAAE,+EAA+E;SAC5F;QACD;YAEI,YAAY,EAAE,0BAA0B;YACxC,QAAQ,EAAE,6DAA6D;YACvE,YAAY,EAAE,EAAE;YAChB,QAAQ,EAAE,oCAAoC;SACjD;QACD;YAEI,YAAY,EAAE,0BAA0B;YACxC,QAAQ,EAAE,6DAA6D;YACvE,YAAY,EAAE,gFAAgF;YAC9F,QAAQ,EAAE,uFAAuF;gBACjG,4DAA4D;gBAC5D,uEAAuE;SAC1E;KACJ,CAAC;IAEF;QAAmC,iCAAW;QAkC1C,uBAAY,EAAyB,EAAE,IAAY,EAAE,IAAY,EAAE,UAAkB;YAArF,iBAeC;YAdG,IAAM,GAAG,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC;YAClC,QAAA,kBAAM,EAAE,EACJ,IAAI,CAAC,OAAO,CAAC,qBAAqB,EAAE,GAAG,CAAC,YAAY,CAAC;iBAChD,OAAO,CAAC,iBAAiB,EAAE,GAAG,CAAC,QAAQ,CAAC,EAC7C,IAAI,CAAC,OAAO,CAAC,qBAAqB,EAAE,GAAG,CAAC,YAAY,CAAC;iBAChD,OAAO,CAAC,iBAAiB,EAAE,GAAG,CAAC,QAAQ,CAAC,CAAC,SAAC;YAEnD,KAAI,CAAC,IAAI,EAAE,CAAC;YACZ,KAAI,CAAC,UAAU,GAAG,UAAU,CAAC;YAC7B,KAAI,CAAC,QAAQ,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YAClC,KAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAI,CAAC,CAAC;YAE5B,KAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,IAAI,YAAY,CAAC,CAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,CAAC,CAAC,CAAC;YACnD,KAAI,CAAC,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;;QACpC,CAAC;QA5CM,uBAAS,GAAG,maAkB1B,CAAC;QA2BE,oBAAC;KAAA,AAlDD,CAAmC,IAAI,CAAC,MAAM,GAkD7C;IAlDY,0BAAa,gBAkDzB,CAAA;AACL,CAAC,EApFS,YAAY,KAAZ,YAAY,QAoFrB;ACjFD,IAAU,YAAY,CAqFrB;AArFD,WAAU,YAAY;IACrB,IAAM,WAAW,GAAG,o+CAsEpB,CAAC;IASE;QAAqC,mCAAa;QAC9C,yBAAY,EAAyB,EAAE,UAAkB;mBACrD,kBAAM,EAAE,EAAE,aAAA,aAAa,CAAC,SAAS,EAAE,WAAW,EAAE,UAAU,CAAC;QAC/D,CAAC;QACL,sBAAC;IAAD,CAAC,AAJD,CAAqC,aAAA,aAAa,GAIjD;IAJY,4BAAe,kBAI3B,CAAA;AACL,CAAC,EArFS,YAAY,KAAZ,YAAY,QAqFrB;ACrFD,IAAU,YAAY,CAqFrB;AArFD,WAAU,YAAY;IACrB,IAAM,WAAW,GAAG,m7CAsEpB,CAAC;IASE;QAAsC,oCAAa;QAC/C,0BAAY,EAAyB,EAAE,UAAkB;mBACrD,kBAAM,EAAE,EAAE,aAAA,aAAa,CAAC,SAAS,EAAE,WAAW,EAAE,UAAU,CAAC;QAC/D,CAAC;QACL,uBAAC;IAAD,CAAC,AAJD,CAAsC,aAAA,aAAa,GAIlD;IAJY,6BAAgB,mBAI5B,CAAA;AACL,CAAC,EArFS,YAAY,KAAZ,YAAY,QAqFrB;ACrFD,IAAU,YAAY,CAiFrB;AAjFD,WAAU,YAAY;IACrB,IAAM,WAAW,GAAG,+7CAkEpB,CAAC;IASE;QAAiC,+BAAa;QAC1C,qBAAY,EAAyB,EAAE,UAAkB;mBACrD,kBAAM,EAAE,EAAE,aAAA,aAAa,CAAC,SAAS,EAAE,WAAW,EAAE,UAAU,CAAC;QAC/D,CAAC;QACL,kBAAC;IAAD,CAAC,AAJD,CAAiC,aAAA,aAAa,GAI7C;IAJY,wBAAW,cAIvB,CAAA;AACL,CAAC,EAjFS,YAAY,KAAZ,YAAY,QAiFrB;AClFD,IAAU,YAAY,CAsDrB;AAtDD,WAAU,YAAY;IACrB,IAAM,WAAW,GAAG,ivBA+BpB,CAAC;IAiBE;QAAkC,gCAAa;QAC3C,sBAAY,EAAyB,EAAE,UAAkB;mBACrD,kBAAM,EAAE,EAAE,aAAA,aAAa,CAAC,SAAS,EAAE,WAAW,EAAE,UAAU,CAAC;QAC/D,CAAC;QACL,mBAAC;IAAD,CAAC,AAJD,CAAkC,aAAA,aAAa,GAI9C;IAJY,yBAAY,eAIxB,CAAA;AACL,CAAC,EAtDS,YAAY,KAAZ,YAAY,QAsDrB;ACtDD,IAAU,YAAY,CAiDrB;AAjDD,WAAU,YAAY;IACrB,IAAM,WAAW,GAAG,sxBAkCpB,CAAC;IASE;QAAsC,oCAAa;QAC/C,0BAAY,EAAyB,EAAE,UAAkB;mBACrD,kBAAM,EAAE,EAAE,aAAA,aAAa,CAAC,SAAS,EAAE,WAAW,EAAE,UAAU,CAAC;QAC/D,CAAC;QACL,uBAAC;IAAD,CAAC,AAJD,CAAsC,aAAA,aAAa,GAIlD;IAJY,6BAAgB,mBAI5B,CAAA;AACL,CAAC,EAjDS,YAAY,KAAZ,YAAY,QAiDrB;ACnDD,IAAU,YAAY,CAuXrB;AAvXD,WAAU,YAAY;IACrB,4BAAmC,EAAsB;QACxD,EAAE,CAAC,CAAE,EAAU,CAAC,eAAe,CAAC;YAAC,MAAM,CAAC;QAExC,EAAE,CAAC,UAAU,GAAG,UAAiB,CAAC;QAClC,EAAE,CAAC,SAAS,GAAG,SAAgB,CAAC;QAChC,EAAE,CAAC,YAAY,GAAG,YAAmB,CAAC;QACrC,EAAU,CAAC,eAAe,GAAG,eAAe,CAAC;IAC/C,CAAC;IAPe,+BAAkB,qBAOjC,CAAA;IAED,oBAAoB,MAA0B,EAAE,OAAmC;QAClF,IAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAE/B,IAAI,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;QAEjC,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,CAChB,CAAC;YACA,UAAU,GAAG,IAAI,CAAC,QAAQ,CAAC,mBAAmB,CAAC,WAAW,CAAC;YAG3D,IAAM,WAAW,GAAG,IAAI,WAAW,EAAE,CAAC;YAEtC,WAAW,CAAC,WAAW,GAAG,WAAW,CAAC,gBAAgB,GAAG,IAAI,CAAC,QAAQ,CAAC,mBAAmB,CAAC,IAAI,CAAC;YAChG,WAAW,CAAC,YAAY,GAAG,QAAQ,CAAC,mBAAmB,CAAC;YAExD,IAAI,CAAC,QAAQ,CAAC,mBAAmB,CAAC,UAAU,GAAG,UAAU,GAAG;gBAC3D,KAAK,EAAE,CAAC;gBACR,KAAK,EAAE,CAAC,WAAW,CAAC;aACpB,CAAC;YAEF,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC9B,CAAC;QAGD,IAAI,YAAY,GAAG,UAAU,CAAC,KAAK,CAAC,EAAE,UAAU,CAAC,KAAK,CAAC,CAAC;QACxD,IAAM,iBAAiB,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC;QAE/D,EAAE,CAAC,CAAC,CAAC,YAAY,CAAC,CAClB,CAAC;YACA,YAAY,GAAG,UAAU,CAAC,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,IAAI,WAAW,EAAE,CAAC;QACvE,CAAC;QAED,IAAM,UAAU,GAAG,MAAM,CAAC,UAAU;eAChC,MAAM,CAAC,UAAU,CAAC,CAAC,KAAK,CAAC;eACzB,MAAM,CAAC,UAAU,CAAC,CAAC,KAAK,CAAC;eACzB,MAAM,CAAC,UAAU,CAAC,KAAK,KAAK,QAAQ,CAAC,MAAM,CAAC,KAAK;eACjD,MAAM,CAAC,UAAU,CAAC,MAAM,KAAK,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC;QAGxD,IAAM,UAAU,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC;QACzC,IAAM,OAAO,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,GAAG,CAAC,CAAC;QACvC,IAAM,YAAY,GAAG,UAAU,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,MAAM,CAAC,UAAU,IAAI,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;QAClG,IAAM,WAAW,GAAG,YAAY,CAAC,WAAW,CAAC;QAC7C,IAAM,gBAAgB,GAAG,YAAY,CAAC,gBAAgB,CAAC;QAEvD,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,YAAY,CAAC,CAAC,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC;QACjE,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,YAAY,CAAC,CAAC,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC;QACjE,WAAW,CAAC,KAAK,GAAG,CAAC,CAAC,YAAY,CAAC,KAAK,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC;QACzE,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,YAAY,CAAC,MAAM,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC;QAE3E,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,CAChB,CAAC;YACA,EAAE,CAAC,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,SAAS,CAAC,CAC/C,CAAC;YAGD,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAC5B,CAAC;gBACA,WAAW,CAAC,GAAG,CAAC,iBAAiB,CAAC,CAAC;YACpC,CAAC;YAID,WAAW,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QAC1B,CAAC;QAED,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EACvC,CAAC;YACA,IAAI,QAAQ,GAAG,IAAI,CAAC;YACpB,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,mBAAmB,CAAC,CACnC,CAAC;gBACA,EAAE,CAAC,CAAC,QAAQ,KAAK,IAAI,CAAC,CACtB,CAAC;oBACA,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC;gBAC9C,CAAC;gBACD,OAAO,CAAC,CAAC,CAAC,CAAC,qBAAqB,GAAG,QAAQ,CAAC;YAC7C,CAAC;QACF,CAAC;QAED,gBAAgB,CAAC,KAAK,GAAG,WAAW,CAAC,KAAK,CAAC;QAC3C,gBAAgB,CAAC,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC;QAK7C,IAAM,YAAY,GAAG,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,EAAE,EAAE,WAAW,CAAC,KAAK,EAAE,WAAW,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;QAE7G,YAAY,CAAC,MAAM,GAAG,MAAM,CAAC;QAC7B,YAAY,CAAC,OAAO,GAAG,OAAO,CAAC;QAC/B,YAAY,CAAC,UAAU,GAAG,UAAU,CAAC;QACrC,YAAY,CAAC,YAAY,GAAG,YAAY,CAAC;QAIzC,YAAY,CAAC,QAAQ,CAAC,gBAAgB,EAAE,WAAW,CAAC,CAAC;QAGrD,QAAQ,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAC;QACxC,YAAY,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;IAC5D,CAAC;IAED;QACC,IAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;QAEnC,IAAM,SAAS,GAAG,UAAU,CAAC,KAAK,CAAC,UAAU,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;QACzD,IAAM,YAAY,GAAG,UAAU,CAAC,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;QAExD,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,YAAY,CAAC,IAAI,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC,MAAM,EAAE,CAAC;QAEjF,IAAM,OAAO,GAAG,YAAY,CAAC,OAAO,CAAC;QAErC,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,CAAC,CACzB,CAAC;YACA,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,EAAE,YAAY,CAAC,YAAY,EAAE,SAAS,CAAC,YAAY,EAAE,KAAK,EAAE,YAAY,CAAC,CAAC;YAC/F,IAAI,CAAC,mBAAmB,CAAC,YAAY,CAAC,YAAY,CAAC,CAAC;QACrD,CAAC;QACD,IAAI,CACJ,CAAC;YACA,IAAI,IAAI,GAAG,YAAY,CAAC,YAAY,CAAC;YACrC,IAAI,IAAI,GAAG,IAAI,CAAC,kBAAkB,CACjC,IAAI,CAAC,QAAQ,CAAC,EAAE,EAChB,YAAY,CAAC,WAAW,CAAC,KAAK,EAC9B,YAAY,CAAC,WAAW,CAAC,MAAM,EAC/B,YAAY,CAAC,UAAU,CACvB,CAAC;YAEF,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,gBAAgB,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC;YAGvE,IAAI,CAAC,KAAK,EAAE,CAAC;YAEb,IAAI,CAAC,GAAG,CAAC,CAAC;YAEV,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE,EAAE,CAAC,EACvC,CAAC;gBACA,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,YAAY,CAAC,CAAC;gBAEvD,IAAM,CAAC,GAAG,IAAI,CAAC;gBAEf,IAAI,GAAG,IAAI,CAAC;gBACZ,IAAI,GAAG,CAAC,CAAC;YACV,CAAC;YAED,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,EAAE,SAAS,CAAC,YAAY,EAAE,KAAK,EAAE,YAAY,CAAC,CAAC;YAE1E,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;YAC/B,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;QAChC,CAAC;QAED,YAAY,CAAC,KAAK,EAAE,CAAC;QAErB,IAAI,YAAY,GAAG,KAAK,CAAC;QACzB,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EACvC,CAAC;YACA,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,qBAAqB,CAAC,CACrC,CAAC;gBACA,EAAE,CAAC,CAAC,CAAC,YAAY,CAAC,CAClB,CAAC;oBACA,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,qBAAqB,CAAC,CAAC;oBAC3D,YAAY,GAAG,IAAI,CAAC;gBACrB,CAAC;gBACD,OAAO,CAAC,CAAC,CAAC,CAAC,qBAAqB,GAAG,IAAI,CAAC;YACzC,CAAC;QACF,CAAC;QAED,UAAU,CAAC,KAAK,EAAE,CAAC;QAEnB,EAAE,CAAC,CAAC,UAAU,CAAC,KAAK,KAAK,CAAC,CAAC,CAC3B,CAAC;YACA,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACxB,CAAC;IACF,CAAC;IAED,sBAAsB,MAA4B,EAAE,MAA2B;QAC9E,IAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC/B,IAAM,EAAE,GAAG,QAAQ,CAAC,EAAE,CAAC;QACvB,IAAM,WAAW,GAAG,MAAM,CAAC,WAAW,CAAC;QACvC,IAAM,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC;QAGjC,IAAI,YAAY,GAAG,CAAC,CAAC;QACrB,IAAI,YAAY,CAAC;QAKjB,EAAE,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,UAAU,CAAC,CAC/B,CAAC;YACA,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;YAE5D,IAAM,UAAU,GAAG,MAAM,CAAC,QAAQ,CAAC,UAAU,CAAC;YAE9C,UAAU,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC;YACrD,UAAU,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC;YACtD,UAAU,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,WAAW,CAAC,CAAC,CAAC;YAC3C,UAAU,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,WAAW,CAAC,CAAC,CAAC;YAE3C,MAAM,CAAC,QAAQ,CAAC,UAAU,GAAG,UAAU,CAAC;QACzC,CAAC;QAID,EAAE,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,WAAW,CAAC,CAChC,CAAC;YACA,YAAY,GAAG,YAAY,IAAI,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;YAE5E,IAAM,WAAW,GAAG,MAAM,CAAC,QAAQ,CAAC,WAAW,CAAC;YAEhD,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;YACnB,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;YACnB,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC,YAAY,CAAC,WAAW,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,YAAY,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC;YAC7F,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC,YAAY,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,YAAY,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC;YAE/F,MAAM,CAAC,QAAQ,CAAC,WAAW,GAAG,WAAW,CAAC;QAC3C,CAAC;QAGD,GAAG,CAAC,CAAC,IAAM,CAAC,IAAI,WAAW,CAAC,CAC5B,CAAC;YACA,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAC7B,CAAC;gBACA,QAAQ,CAAC;YACV,CAAC;YAED,EAAE,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,mBAAmB,CAAC,CACrC,CAAC;gBACA,IAAM,EAAE,GAAG,MAAM,CAAC,qBAAqB,CAAC;gBACxC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC;gBAClC,QAAQ,CAAC,aAAa,CAAC,YAAY,CAAC,GAAG,QAAQ,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;gBAC5E,EAAE,CAAC,aAAa,CAAC,EAAE,CAAC,QAAQ,GAAG,YAAY,CAAC,CAAC;gBAC7C,EAAE,CAAC,WAAW,CAAC,EAAE,CAAC,UAAU,EAAG,EAAE,CAAC,OAAe,CAAC,OAAO,CAAC,CAAC;gBAC3D,YAAY,EAAE,CAAC;gBACf,QAAQ,CAAC;YACV,CAAC;YAED,IAAM,IAAI,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;YAEjC,EAAE,CAAC,CAAC,IAAI,KAAK,WAAW,IAAI,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAC9C,CAAC;gBACA,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAC5B,CAAC;oBACA,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,YAAY,CAAC,CAAC;gBACvF,CAAC;gBACD,IAAI,CACJ,CAAC;oBACA,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC;oBAElC,IAAM,IAAE,GAAG,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC;oBAE5B,QAAQ,CAAC,aAAa,CAAC,YAAY,CAAC,GAAG,QAAQ,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;oBAC5E,IAAE,CAAC,aAAa,CAAC,IAAE,CAAC,QAAQ,GAAG,YAAY,CAAC,CAAC;oBAE7C,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;gBAC5B,CAAC;gBAED,YAAY,EAAE,CAAC;YAChB,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,KAAK,MAAM,CAAC,CACzB,CAAC;gBAEA,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC,CAChC,CAAC;oBACA,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;gBAChD,CAAC;gBACD,IAAI,CACJ,CAAC;oBACA,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAClC,CAAC;YACF,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,KAAK,MAAM,CAAC,CACzB,CAAC;gBAEA,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC,CAChC,CAAC;oBACA,IAAM,GAAG,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,IAAI,YAAY,CAAC,CAAC,CAAC,CAAC;oBAEtD,GAAG,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACvB,GAAG,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACvB,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;gBAC1B,CAAC;gBACD,IAAI,CACJ,CAAC;oBACA,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAClC,CAAC;YACF,CAAC;YACD,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,KAAK,OAAO,CAAC,CAC1B,CAAC;gBACA,EAAE,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,KAAK,WAAW,CAAC,CAAC,CAAC,CAAC,CACrD,CAAC;oBACA,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAClC,CAAC;YACF,CAAC;YACD,IAAI,CACJ,CAAC;gBACA,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YAClC,CAAC;QACF,CAAC;IACF,CAAC;IASD,yBAAyB,MAAsB;QAE9C,IAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC/B,IAAM,YAAY,GAAG,QAAQ,CAAC,mBAAmB,CAAC;QAClD,EAAE,CAAC,CAAC,YAAY,CAAC,IAAI,CAAC,CACtB,CAAC;YACA,MAAM,CAAC,IAAI,CAAC;QACb,CAAC;QACD,IAAM,UAAU,GAAG,YAAY,CAAC,UAAU,CAAC;QAC3C,IAAM,EAAE,GAAG,YAAY,CAAC,WAAW,IAAI,YAAY,CAAC,gBAAgB,CAAC;QACrE,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACf,IAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC;QACzC,IAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC;QACzC,IAAM,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,UAAU,CAAC;QACtC,IAAM,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,UAAU,CAAC;QACvC,IAAM,EAAE,GAAG,QAAQ,CAAC,EAAE,CAAC;QACvB,IAAM,EAAE,GAAG,IAAI,CAAC,kBAAkB,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAChD,QAAQ,CAAC,aAAa,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;QACtD,EAAE,CAAC,aAAa,CAAC,EAAE,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC;QAClC,EAAE,CAAC,WAAW,CAAC,EAAE,CAAC,UAAU,EAAE,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;QAGlD,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC;YACjB,QAAQ,CAAC,mBAAmB,GAAG,IAAI,CAAC;YACpC,QAAQ,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAC;YACxC,EAAE,CAAC,OAAO,GAAG,IAAI,CAAC;QACnB,CAAC;QAED,EAAE,CAAC,iBAAiB,CAAC,EAAE,CAAC,UAAU,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QACzD,MAAM,CAAC,EAAE,CAAC;IACX,CAAC;IAED;QAAA;YAEC,iBAAY,GAAuB,IAAI,CAAC;YACxC,WAAM,GAAuB,IAAI,CAAC;YAClC,eAAU,GAAW,CAAC,CAAC;YACvB,gBAAW,GAAG,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;YACnC,qBAAgB,GAAG,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;YACxC,YAAO,GAA+B,EAAE,CAAC;QAW1C,CAAC;QANA,2BAAK,GAAL;YAEC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;YACpB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;YACnB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QAC1B,CAAC;QACF,kBAAC;IAAD,CAAC,AAlBD,IAkBC;IAED;QAAuC,kCAAc;QAArD;YAAA,qEAKC;YAJA,yBAAmB,GAAW,IAAI,CAAC;YACnC,2BAAqB,GAAsB,IAAI,CAAC;YAChD,gBAAU,GAAiB,IAAI,CAAC;;QAEjC,CAAC;QAAD,qBAAC;IAAD,CAAC,AALD,CAAuC,IAAI,CAAC,MAAM,GAKjD;IALY,2BAAc,iBAK1B,CAAA;AACF,CAAC,EAvXS,YAAY,KAAZ,YAAY,QAuXrB;ACrXD,IAAU,YAAY,CAgErB;AAhED,WAAU,YAAY;IACrB,IAAM,WAAW,GAAG,uoCAiDpB,CAAC;IASE;QAAqC,mCAAa;QAC9C,yBAAY,EAAyB,EAAE,UAAkB;mBACrD,kBAAM,EAAE,EAAE,aAAA,aAAa,CAAC,SAAS,EAAE,WAAW,EAAE,UAAU,CAAC;QAC/D,CAAC;QACL,sBAAC;IAAD,CAAC,AAJD,CAAqC,aAAA,aAAa,GAIjD;IAJY,4BAAe,kBAI3B,CAAA;AACL,CAAC,EAhES,YAAY,KAAZ,YAAY,QAgErB;AC/DD,IAAU,YAAY,CAoKrB;AApKD,WAAU,YAAY;IACrB,IAAM,WAAW,GAAG,y8FAqJpB,CAAC;IASE;QAA+B,6BAAa;QACxC,mBAAY,EAAyB,EAAE,UAAkB;mBACrD,kBAAM,EAAE,EAAE,aAAA,aAAa,CAAC,SAAS,EAAE,WAAW,EAAE,UAAU,CAAC;QAC/D,CAAC;QACL,gBAAC;IAAD,CAAC,AAJD,CAA+B,aAAA,aAAa,GAI3C;IAJY,sBAAS,YAIrB,CAAA;AACL,CAAC,EApKS,YAAY,KAAZ,YAAY,QAoKrB;ACrKD,IAAU,YAAY,CA+CrB;AA/CD,WAAU,YAAY;IACrB,IAAM,WAAW,GAAG,mvBAgCpB,CAAC;IASE;QAAmC,iCAAa;QAC5C,uBAAY,EAAyB,EAAE,UAAkB;mBACrD,kBAAM,EAAE,EAAE,aAAA,aAAa,CAAC,SAAS,EAAE,WAAW,EAAE,UAAU,CAAC;QAC/D,CAAC;QACL,oBAAC;IAAD,CAAC,AAJD,CAAmC,aAAA,aAAa,GAI/C;IAJY,0BAAa,gBAIzB,CAAA;AACL,CAAC,EA/CS,YAAY,KAAZ,YAAY,QA+CrB;AC/CD,IAAU,YAAY,CAkDrB;AAlDD,WAAU,YAAY;IACrB,IAAM,WAAW,GAAG,q1BAmCpB,CAAC;IASE;QAAsC,oCAAa;QAC/C,0BAAY,EAAyB,EAAE,UAAkB;mBACrD,kBAAM,EAAE,EAAE,aAAA,aAAa,CAAC,SAAS,EAAE,WAAW,EAAE,UAAU,CAAC;QAC/D,CAAC;QACL,uBAAC;IAAD,CAAC,AAJD,CAAsC,aAAA,aAAa,GAIlD;IAJY,6BAAgB,mBAI5B,CAAA;AACL,CAAC,EAlDS,YAAY,KAAZ,YAAY,QAkDrB;AClDD,IAAU,YAAY,CAkDrB;AAlDD,WAAU,YAAY;IACrB,IAAM,WAAW,GAAG,20BAmCpB,CAAC;IASE;QAAuC,qCAAa;QAChD,2BAAY,EAAyB,EAAE,UAAkB;mBACrD,kBAAM,EAAE,EAAE,aAAA,aAAa,CAAC,SAAS,EAAE,WAAW,EAAE,UAAU,CAAC;QAC/D,CAAC;QACL,wBAAC;IAAD,CAAC,AAJD,CAAuC,aAAA,aAAa,GAInD;IAJY,8BAAiB,oBAI7B,CAAA;AACL,CAAC,EAlDS,YAAY,KAAZ,YAAY,QAkDrB;AClDD,IAAU,YAAY,CAkDrB;AAlDD,WAAU,YAAY;IACrB,IAAM,WAAW,GAAG,61BAmCpB,CAAC;IASE;QAAuC,qCAAa;QAChD,2BAAY,EAAyB,EAAE,UAAkB;mBACrD,kBAAM,EAAE,EAAE,aAAA,aAAa,CAAC,SAAS,EAAE,WAAW,EAAE,UAAU,CAAC;QAC/D,CAAC;QACL,wBAAC;IAAD,CAAC,AAJD,CAAuC,aAAA,aAAa,GAInD;IAJY,8BAAiB,oBAI7B,CAAA;AACL,CAAC,EAlDS,YAAY,KAAZ,YAAY,QAkDrB;ACjDD,IAAU,YAAY,CAgFrB;AAhFD,WAAU,YAAY;IACrB,IAAM,WAAW,GAAG,27CAiEpB,CAAC;IASE;QAAsC,oCAAa;QAC/C,0BAAY,EAAyB,EAAE,UAAkB;mBACrD,kBAAM,EAAE,EAAE,aAAA,aAAa,CAAC,SAAS,EAAE,WAAW,EAAE,UAAU,CAAC;QAC/D,CAAC;QACL,uBAAC;IAAD,CAAC,AAJD,CAAsC,aAAA,aAAa,GAIlD;IAJY,6BAAgB,mBAI5B,CAAA;AACL,CAAC,EAhFS,YAAY,KAAZ,YAAY,QAgFrB;ACnFD,IAAU,YAAY,CA+BrB;AA/BD,WAAU,YAAY;IAClB,mCAA0C,EAAyB,EAAE,KAAuC;QAAvC,sBAAA,EAAA,UAAuC;QAExG,IAAI,CAAC,WAAW,CAAC,YAAY,GAAG,EAAE,CAAC;QACnC,IAAI,CAAC,WAAW,CAAC,WAAW,GAAG,EAAE,CAAC;QAClC,IAAI,CAAC,WAAW,CAAC,YAAY,GAAG,EAAE,CAAC;QACnC,IAAI,CAAC,WAAW,CAAC,WAAW,GAAG,EAAE,CAAC;QAIlC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,aAAA,aAAa,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,aAAa,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,aAAa,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;QACjH,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,aAAA,eAAe,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,eAAe,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,eAAe,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;QAC7H,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,aAAA,eAAe,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,eAAe,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,eAAe,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;QAC1H,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,aAAA,YAAY,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,YAAY,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,YAAY,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;QAC7G,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,aAAA,aAAa,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,aAAa,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,aAAa,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;QACjH,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,aAAA,gBAAgB,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,gBAAgB,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,gBAAgB,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;QAC9H,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,aAAA,eAAe,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,eAAe,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,eAAe,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;QACvH,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,aAAA,WAAW,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,eAAe,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,eAAe,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;QACpH,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,aAAA,gBAAgB,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,gBAAgB,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,gBAAgB,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;QAE1H,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,aAAA,iBAAiB,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,iBAAiB,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,iBAAiB,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;QACrI,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,aAAA,gBAAgB,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,gBAAgB,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,gBAAgB,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;QAC9H,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,aAAA,iBAAiB,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,iBAAiB,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,iBAAiB,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;QAElI,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,aAAA,SAAS,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,SAAS,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,SAAS,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;QACjG,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,aAAA,gBAAgB,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,gBAAgB,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,gBAAgB,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;QAC7H,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,aAAA,gBAAgB,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,gBAAgB,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,gBAAgB,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;QAC7H,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,aAAA,gBAAgB,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,gBAAgB,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,gBAAgB,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;QAE3H,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IA7Be,sCAAyB,4BA6BxC,CAAA;AACL,CAAC,EA/BS,YAAY,KAAZ,YAAY,QA+BrB;AC/BD,IAAU,YAAY,CAgDrB;AAhDD,WAAU,YAAY;IAElB,IAAI,UAAU,GAAG,8QAepB,CAAC;IAEE,IAAI,UAAU,GAAG,mTAepB,CAAC;IAEE;QAAkC,gCAAa;QAQ3C,sBAAY,EAAyB,EAAE,UAAkB;mBACrD,kBAAM,EAAE,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,CAAC;QACjD,CAAC;QACL,mBAAC;IAAD,CAAC,AAXD,CAAkC,aAAA,aAAa,GAW9C;IAXY,yBAAY,eAWxB,CAAA;AACL,CAAC,EAhDS,YAAY,KAAZ,YAAY,QAgDrB;AChDD,IAAU,YAAY,CAgErB;AAhED,WAAU,YAAY;IAClB,IAAM,WAAW,GAAG,uoCAiDvB,CAAC;IASE;QAAmC,iCAAa;QAC5C,uBAAY,EAAyB,EAAE,UAAkB;mBACrD,kBAAM,EAAE,EAAE,aAAA,aAAa,CAAC,SAAS,EAAE,WAAW,EAAE,UAAU,CAAC;QAC/D,CAAC;QACL,oBAAC;IAAD,CAAC,AAJD,CAAmC,aAAA,aAAa,GAI/C;IAJY,0BAAa,gBAIzB,CAAA;AACL,CAAC,EAhES,YAAY,KAAZ,YAAY,QAgErB;AChED,IAAU,YAAY,CAwXrB;AAxXD,WAAU,YAAY;IAMlB,IAAO,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;IAEpC,kBAAkB,CAAS;QACvB,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,GAAC,CAAC,GAAC,CAAC,CAAC;QACnB,EAAE,CAAC,CAAC;QACJ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACb,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACb,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACb,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACb,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC;QACd,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;IACjB,CAAC;IAED;QAAqC,mCAAmB;QACpD,yBAAY,QAA4B;mBACpC,kBAAM,QAAQ,CAAC;QACnB,CAAC;QAcD,yCAAe,GAAf;YACC,aAAA,kBAAkB,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC;YAE7C,IAAM,EAAE,GAAG,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC;YAE5B,IAAI,CAAC,SAAS,GAAG,aAAA,yBAAyB,CAAC,EAAE,CAAC,CAAC;YAC/C,IAAI,CAAC,YAAY,GAAG,CAAC,IAAI,aAAA,YAAY,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,YAAY,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,IAAI,aAAA,YAAY,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;YAChG,IAAI,CAAC,UAAU,GAAG,IAAI,YAAY,CAAC,CAAC,CAAC,CAAC;YACtC,IAAI,CAAC,UAAU,GAAG,IAAI,YAAY,CAAC,CAAC,CAAC,CAAC;YACtC,IAAI,CAAC,SAAS,GAAG,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;YACtC,IAAI,CAAC,UAAU,GAAG,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;YACvC,IAAI,CAAC,UAAU,GAAG,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;YACvC,IAAI,CAAC,WAAW,GAAG,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;YACrC,IAAI,CAAC,YAAY,GAAG,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;YACtC,IAAI,CAAC,OAAO,GAAG,IAAI,UAAU,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC;YACvC,IAAI,CAAC,cAAc,GAAG,IAAI,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QACjE,CAAC;QAED,+BAAK,GAAL;QAEA,CAAC;QAED,+BAAK,GAAL;QAEA,CAAC;QAED,2CAAiB,GAAjB,UAAkB,QAAgB,EAAE,SAAiB;YACjD,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,GAAG,QAAQ;gBACpC,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC;gBACzC,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC,CAAC;gBAC9B,SAAS,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC;gBAChC,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;YACpD,CAAC;YACD,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC;QAC/B,CAAC;QAED,iCAAO,GAAP,UAAQ,IAAY;YAChB,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC;YACvB,EAAE,CAAC,CAAC,GAAG,CAAC,MAAM,GAAG,IAAI,CAAC,CAAC,CAAC;gBACpB,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;gBACtB,GAAG,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC;gBAC3B,IAAI,CAAC,OAAO,GAAG,GAAG,CAAC;YACvB,CAAC;YACD,MAAM,CAAC,GAAG,CAAC;QACf,CAAC;QAED,gCAAM,GAAN,UAAO,MAAc;YACjB,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;gBACxB,MAAM,CAAC;YACX,CAAC;YACD,IAAI,UAAU,GAAG,CAAC,CAAC;YACnB,EAAE,CAAC,CAAE,MAAc,CAAC,aAAa,CAAC,CAAC,CAAC;gBAEhC,UAAU,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YACtD,CAAC;YAED,IAAM,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;YACrD,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;gBACd,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,WAAW,CAAC,UAAU,CAAC,CAAC,CAAC;YACvD,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC;YAC9D,CAAC;QACL,CAAC;QAED,uCAAa,GAAb,UAAc,MAAc,EAAE,MAAqB;YAC/C,IAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;YAC/B,QAAQ,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;YAC5B,QAAQ,CAAC,KAAK,CAAC,YAAY,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;YAC9C,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;QACtC,CAAC;QAED,sCAAY,GAAZ,UAAa,MAAc,EAAE,MAAqB;YAE9C,IAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;YAC/B,IAAM,YAAY,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;YACxC,IAAM,YAAY,GAAG,QAAQ,CAAC,mBAAmB,CAAC;YAClD,IAAM,MAAM,GAAG,YAAY,CAAC,gBAAgB,CAAC;YAC7C,IAAM,KAAK,GAAG,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;YAC3B,IAAM,KAAK,GAAG,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;YAC3B,IAAM,UAAU,GAAG,YAAY,CAAC,UAAU,CAAC;YAC3C,IAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC;YAC9B,IAAM,EAAE,GAAG,YAAY,CAAC,WAAW,IAAI,YAAY,CAAC,gBAAgB,CAAC;YACrE,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;YACb,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;YACb,MAAM,CAAC,KAAK,GAAG,EAAE,CAAC,KAAK,CAAC;YACxB,MAAM,CAAC,MAAM,GAAG,EAAE,CAAC,MAAM,CAAC;YAE1B,IAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC;YAC/B,IAAM,GAAG,GAAG,EAAE,CAAC,KAAK,GAAG,UAAU,EAAE,GAAG,GAAG,EAAE,CAAC,MAAM,GAAG,UAAU,CAAC;YAChE,MAAM,CAAC,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,GAAG,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC,GAAG,UAAU,GAAG,GAAG,GAAG,CAAC,CAAC;YAC1E,MAAM,CAAC,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,GAAG,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC,GAAG,UAAU,GAAG,GAAG,GAAG,CAAC,CAAC;YAC1E,MAAM,CAAC,KAAK,GAAG,YAAY,CAAC,KAAK,GAAG,UAAU,CAAC;YAC/C,MAAM,CAAC,MAAM,GAAG,YAAY,CAAC,MAAM,GAAG,UAAU,CAAC;YACjD,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gBACR,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC;YAC7C,CAAC;YACD,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gBACR,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC,CAAC;YAC9C,CAAC;YAED,IAAM,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC;YACrC,IAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;YACrD,IAAM,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;YAClF,IAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;YACrD,IAAM,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;YACpF,IAAM,WAAW,GAAG,GAAG,GAAG,GAAG,CAAC;YAC9B,IAAM,YAAY,GAAG,GAAG,GAAG,GAAG,CAAC;YAC/B,EAAE,CAAC,CAAC,WAAW,IAAI,CAAC,IAAI,YAAY,IAAI,CAAC,CAAC,CAAC,CAAC;gBAExC,MAAM,CAAC;YACX,CAAC;YAED,IAAM,EAAE,GAAG,IAAI,CAAC,iBAAiB,CAAC,WAAW,EAAE,YAAY,CAAC,CAAC;YAC7D,QAAQ,CAAC,WAAW,CAAC,EAAE,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;YAClC,IAAM,EAAE,GAAG,QAAQ,CAAC,EAAE,CAAC;YACvB,EAAE,CAAC,CAAC,QAAQ,CAAC,iBAAiB,IAAI,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;gBAClD,IAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,GAAG,YAAY,GAAG,CAAC,CAAC,CAAC;gBACzD,EAAE,CAAC,UAAU,CAAC,GAAG,EAAE,GAAG,EAAE,WAAW,EAAE,YAAY,EAAE,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,aAAa,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;gBAE5F,EAAE,CAAC,aAAa,CAAC,EAAE,CAAC,UAAU,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,YAAY,EAAE,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,aAAa,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;YACjH,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,EAAE,CAAC,iBAAiB,CAAC,EAAE,CAAC,UAAU,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,WAAW,EAAE,YAAY,CAAC,CAAC;YACtF,CAAC;YAED,QAAQ,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;YAC5B,QAAQ,CAAC,KAAK,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;YACrD,EAAE,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC;gBAC5B,IAAM,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC;gBACnC,SAAS,CAAC,CAAC,GAAG,MAAM,CAAC,KAAK,GAAG,EAAE,CAAC,KAAK,GAAG,YAAY,CAAC,KAAK,CAAC;gBAC3D,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;oBACR,SAAS,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC;oBAC3B,SAAS,CAAC,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,EAAE,CAAC,KAAK,GAAG,CAAC,YAAY,CAAC,CAAC,GAAG,YAAY,CAAC,KAAK,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC;gBACrG,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACJ,SAAS,CAAC,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,EAAE,CAAC,KAAK,GAAG,YAAY,CAAC,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC;gBAC9E,CAAC;gBACD,SAAS,CAAC,CAAC,GAAG,MAAM,CAAC,MAAM,GAAG,EAAE,CAAC,MAAM,GAAG,YAAY,CAAC,MAAM,CAAC;gBAC9D,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;oBACR,SAAS,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC;oBAC3B,SAAS,CAAC,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,EAAE,CAAC,MAAM,GAAG,CAAC,YAAY,CAAC,CAAC,GAAG,YAAY,CAAC,MAAM,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC;gBACvG,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACJ,SAAS,CAAC,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,EAAE,CAAC,MAAM,GAAG,YAAY,CAAC,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC;gBAC/E,CAAC;gBAED,MAAM,CAAC,QAAQ,CAAC,SAAS,GAAG,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YACxD,CAAC;YAED,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;QACtC,CAAC;QAED,sCAAY,GAAZ,UAAa,MAAc,EAAE,MAAqB;YAC9C,IAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;YAC/B,EAAE,CAAC,CAAC,MAAM,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC;gBACxB,IAAI,CAAC,iBAAiB,CAAC,MAAsB,EAAE,MAAM,CAAC,UAAU,KAAK,CAAC,EAAE,MAAM,CAAC,CAAC;YACpF,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;YACvC,CAAC;QACL,CAAC;QAED,2CAAiB,GAAjB,UAAkB,EAAgB,EAAE,QAAiB,EAAE,MAAqB;YACxE,IAAM,IAAI,GAAG,MAAM,CAAC,QAAQ,CAAC;YAC7B,IAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;YAC/B,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YAC3B,IAAI,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;YAE7B,IAAM,MAAM,GAAY,EAAU,CAAC,MAAM,CAAC;YAC1C,IAAM,OAAO,GAAY,EAAU,CAAC,OAAO,CAAC;YAC5C,IAAM,QAAQ,GAAY,EAAU,CAAC,OAAO,CAAC,EAAE,CAAC;YAChD,IAAM,QAAQ,GAAY,EAAU,CAAC,OAAO,CAAC,EAAE,CAAC;YAEhD,IAAM,EAAE,GAAG,MAAM,GAAG,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC;YACnC,IAAM,EAAE,GAAG,MAAM,GAAG,CAAC,QAAQ,CAAC;YAE9B,IAAM,EAAE,GAAG,OAAO,GAAG,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC;YACpC,IAAM,EAAE,GAAG,OAAO,GAAG,CAAC,QAAQ,CAAC;YAE/B,IAAM,EAAE,GAAG,EAAE,CAAC,SAAS,CAAC,cAAc,CAAC;YAEvC,IAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;YACf,IAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;YACf,IAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;YACf,IAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;YACf,IAAM,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC;YACjB,IAAM,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC;YAEjB,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC;YACvC,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC;YAEvC,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC;YACvC,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC;YAEvC,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC;YACvC,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC;YAEvC,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC;YACvC,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC;YAEvC,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC;YAEpB,QAAQ,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;YACzC,QAAQ,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;YAEzC,QAAQ,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;YAC9C,QAAQ,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;YAE9C,IAAI,CAAC,MAAM,EAAE,CAAC;YAEd,IAAM,GAAG,GAAI,EAAU,CAAC,QAAQ,CAAC;YACjC,IAAM,EAAE,GAAG,EAAE,CAAC,aAAa,CAAC,cAAc,CAAC;YAC3C,IAAM,EAAE,GAAG,EAAE,CAAC,WAAW,CAAC;YAC1B,IAAM,QAAQ,GAAa,EAAU,CAAC,QAAQ,CAAC;YAC/C,IAAM,WAAW,GAAmB,EAAU,CAAC,WAAW,CAAC;YAC3D,IAAM,YAAY,GAAmB,EAAU,CAAC,YAAY,CAAC;YAE7D,IAAM,CAAC,GAAG,GAAG,CAAC,KAAK,CAAC;YACpB,IAAM,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC;YACrB,IAAM,CAAC,GAAG,MAAM,CAAC;YACjB,IAAM,CAAC,GAAG,OAAO,CAAC;YAElB,IAAM,OAAO,GAAG,IAAI,CAAC,YAAY,CAAC;YAElC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,EACpB,EAAE,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,EACZ,EAAE,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,EACZ,EAAE,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,EACZ,EAAE,CAAC,EAAE,GAAG,CAAC,EACT,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;YAQf,OAAO,CAAC,MAAM,EAAE,CAAC;YACjB,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACX,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;YAC7B,CAAC;YACD,IAAI,CAAC,CAAC;gBACF,MAAM,CAAC,QAAQ,CAAC,SAAS,GAAG,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;gBACnD,MAAM,CAAC,QAAQ,CAAC,WAAW,GAAG,WAAW,CAAC;gBAC1C,MAAM,CAAC,QAAQ,CAAC,YAAY,GAAG,YAAY,CAAC;YAChD,CAAC;YACD,MAAM,CAAC,QAAQ,CAAC,UAAU,GAAG,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAEnD,IAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC;YAC9B,IAAM,KAAK,GAAG,EAAE,CAAC,UAAU,CAAC;YAE5B,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,EAAE,KAAY,CAAC,CAAC;YAC1C,KAAK,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC;YAClB,KAAK,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC;YAClB,KAAK,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC;YAClB,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;YACjB,MAAM,CAAC,QAAQ,CAAC,MAAM,GAAG,KAAK,CAAC;YAE/B,QAAQ,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;YACnC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QACpD,CAAC;QAED,uCAAa,GAAb,UAAc,MAAc,EAAE,MAAqB;YAC/C,IAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;YAC/B,IAAM,IAAI,GAAG,MAAM,CAAC,QAAQ,CAAC;YAC7B,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YAC3B,IAAM,GAAG,GAAiB,MAAM,CAAC,OAAe,CAAC,IAAI,CAAC;YAItD,IAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;YAC/B,IAAM,EAAE,GAAkB,MAAM,CAAC,UAAU,CAAC;YAC5C,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;gBACzB,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;YAC7B,CAAC;YAID,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC;YACrB,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC;YACrB,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC;YACrB,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC;YACrB,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC;YACrB,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC;YACrB,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC;YACrB,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC;YAGrB,IAAI,CAAC,MAAM,EAAE,CAAC;YAEd,IAAM,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC;YACnC,IAAM,IAAI,GAAG,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC;YACxC,IAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC;YAG9B,IAAM,GAAG,GAAG,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC;YAClC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC;YACxC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;YACzC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC,KAAK,GAAG,GAAG,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC;YACtD,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;YAGxD,MAAM,CAAC,QAAQ,CAAC,aAAa,GAAG,KAAK,CAAC;YAEtC,IAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC;YAC9B,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,EAAE,KAAY,CAAC,CAAC;YAC9C,IAAM,KAAK,GAAG,MAAM,CAAC,UAAU,CAAC;YAGhC,KAAK,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC;YAClB,KAAK,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC;YAClB,KAAK,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC;YAClB,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;YACjB,MAAM,CAAC,QAAQ,CAAC,MAAM,GAAG,KAAK,CAAC;YAG/B,QAAQ,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;YACpC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QACpD,CAAC;QAED,yCAAe,GAAf,UAAgB,EAAU;YACtB,IAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;YAC/B,IAAM,GAAG,GAAc,EAAU,CAAC,QAAQ,CAAC;YAC3C,IAAM,OAAO,GAAG,GAAG,CAAC,WAAW,CAAC;YAChC,IAAI,QAAQ,GAAI,OAAe,CAAC,YAAY,IAAI,GAAG,CAAC,KAAK,CAAC,KAAK,KAAK,OAAO,CAAC,KAAK,IAAI,GAAG,CAAC,KAAK,CAAC,MAAM,KAAK,OAAO,CAAC,MAAM,CAAC;YAGzH,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACX,EAAE,CAAC,CAAC,CAAE,OAAe,CAAC,WAAW,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;oBACtD,EAAE,CAAC,CAAC,OAAO,CAAC,QAAQ,KAAK,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;wBACxC,OAAO,CAAC,QAAQ,GAAG,UAAU,CAAC,MAAM,CAAC;oBACzC,CAAC;gBACL,CAAC;gBACD,IAAI,CAAC,CAAC;oBACF,QAAQ,GAAG,OAAO,CAAC,QAAQ,KAAK,UAAU,CAAC,KAAK,CAAC;gBACrD,CAAC;YACL,CAAC;YAED,MAAM,CAAC,QAAQ,CAAC;QACpB,CAAC;QACL,sBAAC;IAAD,CAAC,AAjWD,CAAqC,IAAI,CAAC,cAAc,GAiWvD;IAjWY,4BAAe,kBAiW3B,CAAA;IAED,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,SAAS,EAAE,eAAe,CAAC,CAAC;IAC9D,IAAI,CAAC,cAAc,CAAC,cAAc,CAAC,SAAS,EAAE,IAAI,CAAC,oBAA2B,CAAC,CAAC;AACpF,CAAC,EAxXS,YAAY,KAAZ,YAAY,QAwXrB;ACrXD,IAAU,YAAY,CAoKrB;AApKD,WAAU,YAAY;IACrB,IAAM,WAAW,GAAG,y8FAqJpB,CAAC;IASE;QAAsC,oCAAa;QAC/C,0BAAY,EAAyB,EAAE,UAAkB;mBACrD,kBAAM,EAAE,EAAE,aAAA,aAAa,CAAC,SAAS,EAAE,WAAW,EAAE,UAAU,CAAC;QAC/D,CAAC;QACL,uBAAC;IAAD,CAAC,AAJD,CAAsC,aAAA,aAAa,GAIlD;IAJY,6BAAgB,mBAI5B,CAAA;AACL,CAAC,EApKS,YAAY,KAAZ,YAAY,QAoKrB;ACvKD,IAAU,YAAY,CAkGrB;AAlGD,WAAU,YAAY;IAClB,IAAM,aAAa,GAAG,suDAmFzB,CAAC;IASE;QAAqC,mCAAa;QAC9C,yBAAY,EAAyB,EAAE,UAAkB;mBACrD,kBAAM,EAAE,EAAE,aAAA,aAAa,CAAC,SAAS,EAAE,aAAa,EAAE,UAAU,CAAC;QACjE,CAAC;QACL,sBAAC;IAAD,CAAC,AAJD,CAAqC,aAAA,aAAa,GAIjD;IAJY,4BAAe,kBAI3B,CAAA;AACL,CAAC,EAlGS,YAAY,KAAZ,YAAY,QAkGrB;AClGD,IAAU,YAAY,CAOrB;AAPD,WAAU,YAAY;IAClB;QAA4B,0BAAW;QACnC,gBAAY,OAAqB;YAAjC,YACI,kBAAM,OAAO,CAAC,SAEjB;YADG,KAAI,CAAC,UAAU,GAAG,SAAS,CAAA;;QAC/B,CAAC;QACL,aAAC;IAAD,CAAC,AALD,CAA4B,IAAI,CAAC,MAAM,GAKtC;IALY,mBAAM,SAKlB,CAAA;AACL,CAAC,EAPS,YAAY,KAAZ,YAAY,QAOrB;ACPD,IAAU,YAAY,CAOrB;AAPD,WAAU,YAAY;IAClB;QAAkC,gCAAwB;QACtD,sBAAY,OAAqB;YAAjC,YACI,kBAAM,OAAO,CAAC,SAEjB;YADG,KAAI,CAAC,UAAU,GAAG,SAAS,CAAA;;QAC/B,CAAC;QACL,mBAAC;IAAD,CAAC,AALD,CAAkC,IAAI,CAAC,MAAM,CAAC,YAAY,GAKzD;IALY,yBAAY,eAKxB,CAAA;AACL,CAAC,EAPS,YAAY,KAAZ,YAAY,QAOrB;ACLD,IAAU,YAAY,CA2GrB;AA3GD,WAAU,YAAY;IACrB,IAAM,aAAa,GAAG,sjEA4FtB,CAAC;IASE;QAAsC,oCAAa;QAC/C,0BAAY,EAAyB,EAAE,UAAkB;mBACrD,kBAAM,EAAE,EAAE,aAAA,aAAa,CAAC,SAAS,EAAE,aAAa,EAAE,UAAU,CAAC;QACjE,CAAC;QACL,uBAAC;IAAD,CAAC,AAJD,CAAsC,aAAA,aAAa,GAIlD;IAJY,6BAAgB,mBAI5B,CAAA;AACL,CAAC,EA3GS,YAAY,KAAZ,YAAY,QA2GrB;AC5GD,IAAU,YAAY,CAErB;AAFD,WAAU,YAAY;IACpB,IAAY,CAAC,OAAO,GAAG,YAAY,CAAC;AACtC,CAAC,EAFS,YAAY,KAAZ,YAAY,QAErB","sourcesContent":["namespace pixi_picture {\n    interface InnerLib {\n        vertUniforms: string,\n        vertCode: string,\n        fragUniforms: string,\n        fragCode: string\n    }\n\n    const shaderLib: InnerLib[] = [\n        {\n            vertUniforms: \"\",\n            vertCode: \"vTextureCoord = aTextureCoord;\",\n            fragUniforms: \"uniform vec4 uTextureClamp;\",\n            fragCode: \"vec2 textureCoord = clamp(vTextureCoord, uTextureClamp.xy, uTextureClamp.zw);\"\n        },\n        {\n            //DOES HAVE translationMatrix\n            vertUniforms: \"uniform mat3 uTransform;\",\n            vertCode: \"vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\",\n            fragUniforms: \"\",\n            fragCode: \"vec2 textureCoord = vTextureCoord;\"\n        },\n        {\n            //DOES HAVE translationMatrix\n            vertUniforms: \"uniform mat3 uTransform;\",\n            vertCode: \"vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\",\n            fragUniforms: \"uniform mat3 uMapCoord;\\nuniform vec4 uClampFrame;\\nuniform vec2 uClampOffset;\",\n            fragCode: \"vec2 textureCoord = mod(vTextureCoord - uClampOffset, vec2(1.0, 1.0)) + uClampOffset;\" +\n            \"\\ntextureCoord = (uMapCoord * vec3(textureCoord, 1.0)).xy;\" +\n            \"\\ntextureCoord = clamp(textureCoord, uClampFrame.xy, uClampFrame.zw);\"\n        }\n    ];\n\n    export class PictureShader extends PIXI.Shader {\n\n        tempQuad: PIXI.Quad;\n        tilingMode: number;\n\n        static blendVert = `\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform mat3 mapMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\n%SPRITE_UNIFORMS%\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    %SPRITE_CODE%\n    vMapCoord = (mapMatrix * vec3(aVertexPosition, 1.0)).xy;\n}\n`;\n\n        /**\n         * @class\n         * @extends PIXI.Shader\n         * @memberof PIXI.extras\n         * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n         * @param vert {string}\n         * @param frag {string}\n         * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\n         */\n        constructor(gl: WebGLRenderingContext, vert: string, frag: string, tilingMode: number) {\n            const lib = shaderLib[tilingMode];\n            super(gl,\n                vert.replace(/%SPRITE_UNIFORMS%/gi, lib.vertUniforms)\n                    .replace(/%SPRITE_CODE%/gi, lib.vertCode),\n                frag.replace(/%SPRITE_UNIFORMS%/gi, lib.fragUniforms)\n                    .replace(/%SPRITE_CODE%/gi, lib.fragCode));\n\n            this.bind();\n            this.tilingMode = tilingMode;\n            this.tempQuad = new PIXI.Quad(gl);\n            this.tempQuad.initVao(this);\n\n            this.uniforms.uColor = new Float32Array([1,1,1,1]);\n            this.uniforms.uSampler = [0, 1];\n        }\n    }\n}\n","\t\n/// <reference path=\"PictureShader.ts\" />\n\nnamespace pixi_picture {\n\tconst overlayFrag = `\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler[2];\nuniform vec4 uColor;\n%SPRITE_UNIFORMS%\n\nvoid main(void)\n{\n    %SPRITE_CODE%\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\n    vec4 target = texture2D(uSampler[1], vMapCoord);\n\n    //reverse hardlight\n    if (source.a == 0.0) {\n        gl_FragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    //yeah, premultiplied\n    vec3 Cs = source.rgb/source.a, Cb;\n    if (target.a > 0.0) {\n        Cb = target.rgb / target.a;\n\t}\n\t\n\t// Formula from https://drafts.fxtf.org/compositing/#blendingcolor\n\t// if(Cb == 1)\n\t//     B(Cb, Cs) = 1\n\t// else if(Cs == 0)\n\t//     B(Cb, Cs) = 0\n\t// else\n\t//     B(Cb, Cs) = 1 - min(1, (1 - Cb) / Cs)\n\n\tvec3 Cm;\n\n\t// Can these be combined?\n\t// red\n\tif (Cb.r == 1.0) {\n\t\tCm.r = 1.0;\n\t} else if (Cs.r == 0.0) {\n\t\tCm.r = 0.0;\n\t} else {\n\t\tCm.r = 1.0 - min(1.0, (1.0 - Cb.r) / Cs.r);\n\t}\n\n\t// green\n\tif (Cb.g == 1.0) {\n\t\tCm.g = 1.0;\n\t} else if (Cs.g == 0.0) {\n\t\tCm.g = 0.0;\n\t} else {\n\t\tCm.g = 1.0 - min(1.0, (1.0 - Cb.g) / Cs.g);\n\t}\n\n\t//blue\n\tif (Cb.b == 1.0) {\n\t\tCm.b = 1.0;\n\t} else if (Cs.b == 0.0) {\n\t\tCm.b = 0.0;\n\t} else {\n\t\tCm.b = 1.0 - min(1.0, (1.0 - Cb.b) / Cs.b);\n\t}\n\n\t\n    vec4 res;\n    res.xyz = (1.0 - source.a) * Cb + source.a * Cm;\n    res.a = source.a + target.a * (1.0-source.a);\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\n}\n`;\n\n    /**\n     * @class\n     * @extends PIXI.Shader\n     * @memberof PIXI.extras\n     * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n     * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\n     */\n    export class ColorBurnShader extends PictureShader {\n        constructor(gl: WebGLRenderingContext, tilingMode: number) {\n            super(gl, PictureShader.blendVert, overlayFrag, tilingMode);\n        }\n    }\n}\n","\t\n/// <reference path=\"PictureShader.ts\" />\n\nnamespace pixi_picture {\n\tconst overlayFrag = `\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler[2];\nuniform vec4 uColor;\n%SPRITE_UNIFORMS%\n\nvoid main(void)\n{\n    %SPRITE_CODE%\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\n    vec4 target = texture2D(uSampler[1], vMapCoord);\n\n    if (source.a == 0.0) {\n        gl_FragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    //yeah, premultiplied\n    vec3 Cs = source.rgb/source.a, Cb;\n    if (target.a > 0.0) {\n        Cb = target.rgb / target.a;\n\t}\n\t\n\t// Formula from https://drafts.fxtf.org/compositing/#blendingcolor\n\t// if(Cb == 0)\n\t//     B(Cb, Cs) = 0\n\t// else if(Cs == 1)\n\t//     B(Cb, Cs) = 1\n\t// else\n\t// \tB(Cb, Cs) = min(1.0, Cb / (1.0 - Cs))\n\n\n\tvec3 Cm;\n\n\t// Can these be combined?\n\t// red\n\tif (Cb.r == 0.0) {\n\t\tCm.r = 0.0;\n\t} else if (Cs.r == 1.0) {\n\t\tCm.r = 1.0;\n\t} else {\n\t\tCm.r = min(1.0, Cb.r / (1.0-Cs.r));\n\t}\n\n\t// green\n\tif (Cb.g == 0.0) {\n\t\tCm.g = 0.0;\n\t} else if (Cs.g == 1.0) {\n\t\tCm.g = 1.0;\n\t} else {\n\t\tCm.g = min(1.0, Cb.g / (1.0-Cs.g));\n\t}\n\n\t//blue\n\tif (Cb.b == 0.0) {\n\t\tCm.b = 0.0;\n\t} else if (Cs.b == 1.0) {\n\t\tCm.b = 1.0;\n\t} else {\n\t\tCm.b = min(1.0, Cb.b / (1.0-Cs.b));\n\t}\n\n\t\n    vec4 res;\n    res.xyz = (1.0 - source.a) * Cb + source.a * Cm;\n    res.a = source.a + target.a * (1.0-source.a);\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\n}\n`;\n\n    /**\n     * @class\n     * @extends PIXI.Shader\n     * @memberof PIXI.extras\n     * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n     * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\n     */\n    export class ColorDodgeShader extends PictureShader {\n        constructor(gl: WebGLRenderingContext, tilingMode: number) {\n            super(gl, PictureShader.blendVert, overlayFrag, tilingMode);\n        }\n    }\n}\n","\t\n/// <reference path=\"PictureShader.ts\" />\n\nnamespace pixi_picture {\n\tconst overlayFrag = `\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler[2];\nuniform vec4 uColor;\n%SPRITE_UNIFORMS%\n\n// Functions from https://drafts.fxtf.org/compositing/#blendingcolor\nfloat Lum(vec3 C) {\n\tfloat lum = 0.3 * C.r + 0.59 * C.g + 0.11 * C.b;\n\treturn lum;\n}\n\n\nvec3 ClipColor(vec3 C) {\n\tfloat L = Lum(C);\n\tfloat n = min(C.r, min(C.g, C.b));\n\tfloat x = max(C.r, max(C.g, C.b));\n\tif (n < 0.0) {\n\t\tC = L + (((C - L) * L) / (L - n));\n\t}\n\tif(x > 1.0) {\n\t\tC = L + (((C - L) * (1.0 - L)) / (x - L));\n\t}\n\treturn C;\n}\n\nvec3 SetLum(vec3 C, float l) {\n\tfloat d = l - Lum(C);\n\tC.r = C.r + d;\n\tC.g = C.g + d;\n\tC.b = C.b + d;\n\treturn ClipColor(C);\n}\n\t\n\nvoid main(void)\n{\n    %SPRITE_CODE%\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\n    vec4 target = texture2D(uSampler[1], vMapCoord);\n\n    //reverse hardlight\n    if (source.a == 0.0) {\n        gl_FragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    //yeah, premultiplied\n    vec3 Cs = source.rgb/source.a, Cb;\n    if (target.a > 0.0) {\n        Cb = target.rgb / target.a;\n\t}\n\t\n\t// Formula from https://drafts.fxtf.org/compositing/#blendingcolor\n\t// SetLum(Cs, Lum(Cb))\n\n\tvec3 Cm = SetLum(Cs, Lum(Cb));\n\n\t\n    vec4 res;\n    res.xyz = (1.0 - source.a) * Cb + source.a * Cm;\n    res.a = source.a + target.a * (1.0-source.a);\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\n}\n`;\n\n    /**\n     * @class\n     * @extends PIXI.Shader\n     * @memberof PIXI.extras\n     * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n     * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\n     */\n    export class ColorShader extends PictureShader {\n        constructor(gl: WebGLRenderingContext, tilingMode: number) {\n            super(gl, PictureShader.blendVert, overlayFrag, tilingMode);\n        }\n    }\n}\n\n\n","/// <reference path=\"PictureShader.ts\" />\n\nnamespace pixi_picture {\n\tconst overlayFrag = `\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler[2];\nuniform vec4 uColor;\n%SPRITE_UNIFORMS%\n\nvoid main(void)\n{\n    %SPRITE_CODE%\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\n    vec4 target = texture2D(uSampler[1], vMapCoord);\n\n    if (source.a == 0.0) {\n        gl_FragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    //yeah, premultiplied\n    vec3 Cs = source.rgb/source.a, Cb;\n    if (target.a > 0.0) {\n        Cb = target.rgb / target.a;\n\t}\n    vec3 Cm = min(Cb, Cs);\n\t\n    vec4 res;\n    res.xyz = (1.0 - source.a) * Cb + source.a * Cm;\n    res.a = source.a + target.a * (1.0-source.a);\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\n}\n`;\n\n// 1 - (1-2*(Cs-0.5)) * (1-Cb) = Cs: 0.4, Cb: 0.3 = 1 - (1-2*(0.4-0.5)) * (1-0.3) = 0.16\n// 1 - (1-2Cs - 1) * 1-Cb\n// 1 - 2Cs * (1-Cb)\n\n\n// vec3 screen = Cb + (2Cs - 1.0) - Cb * (Cs * 2.0 - 1.0) = 0.3 + (-0.2) + 0.06 = 0.16\n\n\n    /**\n     * @class\n     * @extends PIXI.Shader\n     * @memberof PIXI.extras\n     * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n     * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\n     */\n    export class DarkenShader extends PictureShader {\n        constructor(gl: WebGLRenderingContext, tilingMode: number) {\n            super(gl, PictureShader.blendVert, overlayFrag, tilingMode);\n        }\n    }\n}\n","/// <reference path=\"PictureShader.ts\" />\n\nnamespace pixi_picture {\n\tconst overlayFrag = `\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler[2];\nuniform vec4 uColor;\n%SPRITE_UNIFORMS%\n\nvoid main(void)\n{\n    %SPRITE_CODE%\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\n    vec4 target = texture2D(uSampler[1], vMapCoord);\n\n    if (source.a == 0.0) {\n        gl_FragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    //yeah, premultiplied\n    vec3 Cs = source.rgb/source.a, Cb;\n    if (target.a > 0.0) {\n        Cb = target.rgb / target.a;\n\t}\n\t\n\t// B(Cb, Cs) = | Cb - Cs |\n\t\n\tvec3 Cm = abs(Cb - Cs);\n\t\n    vec4 res;\n    res.xyz = (1.0 - source.a) * Cb + source.a * Cm;\n    res.a = source.a + target.a * (1.0-source.a);\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\n}\n`;\n\n    /**\n     * @class\n     * @extends PIXI.Shader\n     * @memberof PIXI.extras\n     * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n     * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\n     */\n    export class DifferenceShader extends PictureShader {\n        constructor(gl: WebGLRenderingContext, tilingMode: number) {\n            super(gl, PictureShader.blendVert, overlayFrag, tilingMode);\n        }\n    }\n}\n","namespace pixi_picture {\n\texport function filterManagerMixin(fm: PIXI.FilterManager) {\n\t\tif ((fm as any).prepareBackdrop) return;\n\n\t\tfm.pushFilter = pushFilter as any;\n\t\tfm.popFilter = popFilter as any;\n\t\tfm.syncUniforms = syncUniforms as any;\n\t\t(fm as any).prepareBackdrop = prepareBackdrop;\n\t}\n\n\tfunction pushFilter(target: PIXI.DisplayObject, filters: Array<BackdropFilter<any>>) {\n\t\tconst renderer = this.renderer;\n\n\t\tlet filterData = this.filterData;\n\n\t\tif (!filterData)\n\t\t{\n\t\t\tfilterData = this.renderer._activeRenderTarget.filterStack;\n\n\t\t\t// add new stack\n\t\t\tconst filterState = new FilterState();\n\n\t\t\tfilterState.sourceFrame = filterState.destinationFrame = this.renderer._activeRenderTarget.size;\n\t\t\tfilterState.renderTarget = renderer._activeRenderTarget;\n\n\t\t\tthis.renderer._activeRenderTarget.filterData = filterData = {\n\t\t\t\tindex: 0,\n\t\t\t\tstack: [filterState],\n\t\t\t};\n\n\t\t\tthis.filterData = filterData;\n\t\t}\n\n\t\t// get the current filter state..\n\t\tlet currentState = filterData.stack[++filterData.index];\n\t\tconst renderTargetFrame = filterData.stack[0].destinationFrame;\n\n\t\tif (!currentState)\n\t\t{\n\t\t\tcurrentState = filterData.stack[filterData.index] = new FilterState();\n\t\t}\n\n\t\tconst fullScreen = target.filterArea\n\t\t\t&& target.filterArea.x === 0\n\t\t\t&& target.filterArea.y === 0\n\t\t\t&& target.filterArea.width === renderer.screen.width\n\t\t\t&& target.filterArea.height === renderer.screen.height;\n\n\t\t// for now we go off the filter of the first resolution..\n\t\tconst resolution = filters[0].resolution;\n\t\tconst padding = filters[0].padding | 0;\n\t\tconst targetBounds = fullScreen ? renderer.screen : (target.filterArea || target.getBounds(true));\n\t\tconst sourceFrame = currentState.sourceFrame;\n\t\tconst destinationFrame = currentState.destinationFrame;\n\n\t\tsourceFrame.x = ((targetBounds.x * resolution) | 0) / resolution;\n\t\tsourceFrame.y = ((targetBounds.y * resolution) | 0) / resolution;\n\t\tsourceFrame.width = ((targetBounds.width * resolution) | 0) / resolution;\n\t\tsourceFrame.height = ((targetBounds.height * resolution) | 0) / resolution;\n\n\t\tif (!fullScreen)\n\t\t{\n\t\t\tif (filterData.stack[0].renderTarget.transform)\n\t\t\t{ //\n\n\t\t\t\t// TODO we should fit the rect around the transform..\n\t\t\t}\n\t\t\telse if (filters[0].autoFit)\n\t\t\t{\n\t\t\t\tsourceFrame.fit(renderTargetFrame);\n\t\t\t}\n\n\t\t\t// lets apply the padding After we fit the element to the screen.\n\t\t\t// this should stop the strange side effects that can occur when cropping to the edges\n\t\t\tsourceFrame.pad(padding);\n\t\t}\n\n\t\tfor (let i = 0; i < filters.length; i++)\n\t\t{\n\t\t\tlet backdrop = null;\n\t\t\tif (filters[i].backdropUniformName)\n\t\t\t{\n\t\t\t\tif (backdrop === null)\n\t\t\t\t{\n\t\t\t\t\tbackdrop = this.prepareBackdrop(sourceFrame);\n\t\t\t\t}\n\t\t\t\tfilters[i]._backdropRenderTarget = backdrop;\n\t\t\t}\n\t\t}\n\n\t\tdestinationFrame.width = sourceFrame.width;\n\t\tdestinationFrame.height = sourceFrame.height;\n\n\t\t// lets play the padding after we fit the element to the screen.\n\t\t// this should stop the strange side effects that can occur when cropping to the edges\n\n\t\tconst renderTarget = this.getPotRenderTarget(renderer.gl, sourceFrame.width, sourceFrame.height, resolution);\n\n\t\tcurrentState.target = target;\n\t\tcurrentState.filters = filters;\n\t\tcurrentState.resolution = resolution;\n\t\tcurrentState.renderTarget = renderTarget;\n\n\t\t// bind the render target to draw the shape in the top corner..\n\n\t\trenderTarget.setFrame(destinationFrame, sourceFrame);\n\n\t\t// bind the render target\n\t\trenderer.bindRenderTarget(renderTarget);\n\t\trenderTarget.clear(filters[filters.length - 1].clearColor);\n\t}\n\n\tfunction popFilter() {\n\t\tconst filterData = this.filterData;\n\n\t\tconst lastState = filterData.stack[filterData.index - 1];\n\t\tconst currentState = filterData.stack[filterData.index];\n\n\t\tthis.quad.map(currentState.renderTarget.size, currentState.sourceFrame).upload();\n\n\t\tconst filters = currentState.filters;\n\n\t\tif (filters.length === 1)\n\t\t{\n\t\t\tfilters[0].apply(this, currentState.renderTarget, lastState.renderTarget, false, currentState);\n\t\t\tthis.freePotRenderTarget(currentState.renderTarget);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet flip = currentState.renderTarget;\n\t\t\tlet flop = this.getPotRenderTarget(\n\t\t\t\tthis.renderer.gl,\n\t\t\t\tcurrentState.sourceFrame.width,\n\t\t\t\tcurrentState.sourceFrame.height,\n\t\t\t\tcurrentState.resolution\n\t\t\t);\n\n\t\t\tflop.setFrame(currentState.destinationFrame, currentState.sourceFrame);\n\n\t\t\t// finally lets clear the render target before drawing to it..\n\t\t\tflop.clear();\n\n\t\t\tlet i = 0;\n\n\t\t\tfor (i = 0; i < filters.length - 1; ++i)\n\t\t\t{\n\t\t\t\tfilters[i].apply(this, flip, flop, true, currentState);\n\n\t\t\t\tconst t = flip;\n\n\t\t\t\tflip = flop;\n\t\t\t\tflop = t;\n\t\t\t}\n\n\t\t\tfilters[i].apply(this, flip, lastState.renderTarget, false, currentState);\n\n\t\t\tthis.freePotRenderTarget(flip);\n\t\t\tthis.freePotRenderTarget(flop);\n\t\t}\n\n\t\tcurrentState.clear();\n\n\t\tlet backdropFree = false;\n\t\tfor (let i = 0; i < filters.length; i++)\n\t\t{\n\t\t\tif (filters[i]._backdropRenderTarget)\n\t\t\t{\n\t\t\t\tif (!backdropFree)\n\t\t\t\t{\n\t\t\t\t\tthis.freePotRenderTarget(filters[i]._backdropRenderTarget);\n\t\t\t\t\tbackdropFree = true;\n\t\t\t\t}\n\t\t\t\tfilters[i]._backdropRenderTarget = null;\n\t\t\t}\n\t\t}\n\n\t\tfilterData.index--;\n\n\t\tif (filterData.index === 0)\n\t\t{\n\t\t\tthis.filterData = null;\n\t\t}\n\t}\n\n\tfunction syncUniforms(shader: PIXI.glCore.GLShader, filter: BackdropFilter<any>) {\n\t\tconst renderer = this.renderer;\n\t\tconst gl = renderer.gl;\n\t\tconst uniformData = filter.uniformData;\n\t\tconst uniforms = filter.uniforms;\n\n\t\t// 0 is reserved for the PixiJS texture so we start at 1!\n\t\tlet textureCount = 1;\n\t\tlet currentState;\n\n\t\t// filterArea and filterClamp that are handled by FilterManager directly\n\t\t// they must not appear in uniformData\n\n\t\tif (shader.uniforms.filterArea)\n\t\t{\n\t\t\tcurrentState = this.filterData.stack[this.filterData.index];\n\n\t\t\tconst filterArea = shader.uniforms.filterArea;\n\n\t\t\tfilterArea[0] = currentState.renderTarget.size.width;\n\t\t\tfilterArea[1] = currentState.renderTarget.size.height;\n\t\t\tfilterArea[2] = currentState.sourceFrame.x;\n\t\t\tfilterArea[3] = currentState.sourceFrame.y;\n\n\t\t\tshader.uniforms.filterArea = filterArea;\n\t\t}\n\n\t\t// use this to clamp displaced texture coords so they belong to filterArea\n\t\t// see displacementFilter fragment shader for an example\n\t\tif (shader.uniforms.filterClamp)\n\t\t{\n\t\t\tcurrentState = currentState || this.filterData.stack[this.filterData.index];\n\n\t\t\tconst filterClamp = shader.uniforms.filterClamp;\n\n\t\t\tfilterClamp[0] = 0;\n\t\t\tfilterClamp[1] = 0;\n\t\t\tfilterClamp[2] = (currentState.sourceFrame.width - 1) / currentState.renderTarget.size.width;\n\t\t\tfilterClamp[3] = (currentState.sourceFrame.height - 1) / currentState.renderTarget.size.height;\n\n\t\t\tshader.uniforms.filterClamp = filterClamp;\n\t\t}\n\n\t\t// TODO Caching layer..\n\t\tfor (const i in uniformData)\n\t\t{\n\t\t\tif (!shader.uniforms.data[i])\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (i === filter.backdropUniformName)\n\t\t\t{\n\t\t\t\tconst rt = filter._backdropRenderTarget;\n\t\t\t\tshader.uniforms[i] = textureCount;\n\t\t\t\trenderer.boundTextures[textureCount] = renderer.emptyTextures[textureCount];\n\t\t\t\tgl.activeTexture(gl.TEXTURE0 + textureCount);\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, (rt.texture as any).texture);\n\t\t\t\ttextureCount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst type = uniformData[i].type;\n\n\t\t\tif (type === 'sampler2d' && uniforms[i] !== 0)\n\t\t\t{\n\t\t\t\tif (uniforms[i].baseTexture)\n\t\t\t\t{\n\t\t\t\t\tshader.uniforms[i] = this.renderer.bindTexture(uniforms[i].baseTexture, textureCount);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tshader.uniforms[i] = textureCount;\n\n\t\t\t\t\tconst gl = this.renderer.gl;\n\n\t\t\t\t\trenderer.boundTextures[textureCount] = renderer.emptyTextures[textureCount];\n\t\t\t\t\tgl.activeTexture(gl.TEXTURE0 + textureCount);\n\n\t\t\t\t\tuniforms[i].texture.bind();\n\t\t\t\t}\n\n\t\t\t\ttextureCount++;\n\t\t\t}\n\t\t\telse if (type === 'mat3')\n\t\t\t{\n\t\t\t\t// check if its PixiJS matrix..\n\t\t\t\tif (uniforms[i].a !== undefined)\n\t\t\t\t{\n\t\t\t\t\tshader.uniforms[i] = uniforms[i].toArray(true);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tshader.uniforms[i] = uniforms[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type === 'vec2')\n\t\t\t{\n\t\t\t\t// check if its a point..\n\t\t\t\tif (uniforms[i].x !== undefined)\n\t\t\t\t{\n\t\t\t\t\tconst val = shader.uniforms[i] || new Float32Array(2);\n\n\t\t\t\t\tval[0] = uniforms[i].x;\n\t\t\t\t\tval[1] = uniforms[i].y;\n\t\t\t\t\tshader.uniforms[i] = val;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tshader.uniforms[i] = uniforms[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type === 'float')\n\t\t\t{\n\t\t\t\tif (shader.uniforms.data[i].value !== uniformData[i])\n\t\t\t\t{\n\t\t\t\t\tshader.uniforms[i] = uniforms[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tshader.uniforms[i] = uniforms[i];\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Takes a part of current render target corresponding to bounds\n\t * fits sourceFrame to current render target frame to evade problems\n\t *\n\t * @param {PIXI.Rectangle} bounds backdrop region, can be modified inside\n\t * @returns {PIXI.RenderTarget} pooled renderTexture with backdrop\n\t */\n\tfunction prepareBackdrop(bounds: PIXI.Rectangle): PIXI.RenderTarget\n\t{\n\t\tconst renderer = this.renderer;\n\t\tconst renderTarget = renderer._activeRenderTarget;\n\t\tif (renderTarget.root)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tconst resolution = renderTarget.resolution;\n\t\tconst fr = renderTarget.sourceFrame || renderTarget.destinationFrame;\n\t\tbounds.fit(fr);\n\t\tconst x = (bounds.x - fr.x) * resolution;\n\t\tconst y = (bounds.y - fr.y) * resolution;\n\t\tconst w = (bounds.width) * resolution;\n\t\tconst h = (bounds.height) * resolution;\n\t\tconst gl = renderer.gl;\n\t\tconst rt = this.getPotRenderTarget(gl, w, h, 1);\n\t\trenderer.boundTextures[1] = renderer.emptyTextures[1];\n\t\tgl.activeTexture(gl.TEXTURE0 + 1);\n\t\tgl.bindTexture(gl.TEXTURE_2D, rt.texture.texture);\n\n\t\t// v4 drops current renderTarget on new renderTexture, need to restore it!\n\t\tif (!rt.rebound) {\n\t\t\trenderer._activeRenderTarget = null;\n\t\t\trenderer.bindRenderTarget(renderTarget);\n\t\t\trt.rebound = true;\n\t\t}\n\n\t\tgl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, y, w, h);\n\t\treturn rt;\n\t}\n\n\tclass FilterState\n\t{\n\t\trenderTarget : PIXI.RenderTarget = null;\n\t\ttarget: PIXI.DisplayObject = null;\n\t\tresolution: number = 1;\n\t\tsourceFrame = new PIXI.Rectangle();\n\t\tdestinationFrame = new PIXI.Rectangle();\n\t\tfilters: Array<BackdropFilter<any>> = [];\n\n\t\t/**\n\t\t * clears the state\n\t\t */\n\t\tclear()\n\t\t{\n\t\t\tthis.filters = null;\n\t\t\tthis.target = null;\n\t\t\tthis.renderTarget = null;\n\t\t}\n\t}\n\n\texport class BackdropFilter<T> extends PIXI.Filter<T> {\n\t\tbackdropUniformName: string = null;\n\t\t_backdropRenderTarget: PIXI.RenderTarget = null;\n\t\tclearColor: Float32Array = null;\n\t\tuniformData: PIXI.UniformDataMap<T>;\n\t}\n}\n","/// <reference path=\"PictureShader.ts\" />\n\nnamespace pixi_picture {\n\tconst overlayFrag = `\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler[2];\nuniform vec4 uColor;\n%SPRITE_UNIFORMS%\n\nvoid main(void)\n{\n    %SPRITE_CODE%\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\n    vec4 target = texture2D(uSampler[1], vMapCoord);\n\n    //reverse hardlight\n    if (source.a == 0.0) {\n        gl_FragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    //yeah, premultiplied\n    vec3 Cb = source.rgb/source.a, Cs;\n    if (target.a > 0.0) {\n        Cs = target.rgb / target.a;\n    }\n    vec3 multiply = Cb * Cs * 2.0;\n    vec3 Cs2 = Cs * 2.0 - 1.0;\n    vec3 screen = Cb + Cs2 - Cb * Cs2;\n    vec3 B;\n    if (Cb.r <= 0.5) {\n        B.r = multiply.r;\n    } else {\n        B.r = screen.r;\n    }\n    if (Cb.g <= 0.5) {\n        B.g = multiply.g;\n    } else {\n        B.g = screen.g;\n    }\n    if (Cb.b <= 0.5) {\n        B.b = multiply.b;\n    } else {\n        B.b = screen.b;\n    }\n    vec4 res;\n    res.xyz = (1.0 - source.a) * Cs + source.a * B;\n    res.a = source.a + target.a * (1.0-source.a);\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\n}\n`;\n\n    /**\n     * @class\n     * @extends PIXI.Shader\n     * @memberof PIXI.extras\n     * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n     * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\n     */\n    export class HardLightShader extends PictureShader {\n        constructor(gl: WebGLRenderingContext, tilingMode: number) {\n            super(gl, PictureShader.blendVert, overlayFrag, tilingMode);\n        }\n    }\n}\n","\t\n/// <reference path=\"PictureShader.ts\" />\n\nnamespace pixi_picture {\n\tconst overlayFrag = `\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler[2];\nuniform vec4 uColor;\n%SPRITE_UNIFORMS%\n\n// Functions from https://drafts.fxtf.org/compositing/#blendingcolor\nfloat Lum(vec3 C) {\n\tfloat lum = 0.3 * C.r + 0.59 * C.g + 0.11 * C.b;\n\treturn lum;\n}\n\n\nvec3 ClipColor(vec3 C) {\n\tfloat L = Lum(C);\n\tfloat n = min(C.r, min(C.g, C.b));\n\tfloat x = max(C.r, max(C.g, C.b));\n\tif (n < 0.0) {\n\t\tC = L + (((C - L) * L) / (L - n));\n\t}\n\tif(x > 1.0) {\n\t\tC = L + (((C - L) * (1.0 - L)) / (x - L));\n\t}\n\treturn C;\n}\n\nvec3 SetLum(vec3 C, float l) {\n\tfloat d = l - Lum(C);\n\tC.r = C.r + d;\n\tC.g = C.g + d;\n\tC.b = C.b + d;\n\treturn ClipColor(C);\n}\n\nfloat Sat(vec3 C) {\n\treturn (max(C.r, max(C.g, C.b)) - min(C.r, min(C.g, C.b)));\n}\n\n// Find middle number of 3 numbers\nfloat middleOfThree(float a, float b, float c)\n{\n    if (a > b)\n    {\n\t\tif (b > c) {\n            return b;\n\t\t} else if (a > c) {\n            return c;\n\t\t} else {\n            return a;\n\t\t}\n    }\n    else\n    {\n\t\tif (a > c) {\n            return a;\n\t\t} else if (b > c) {\n            return c;\n\t\t} else {\n            return b;\n\t\t}\n    }\n}\n\nvec3 SetSat(vec3 C, float s) {\n\tfloat Cmax = max(C.r, max(C.g, C.b));\n\tfloat Cmin = min(C.r, min(C.g, C.b));\n\tfloat Cmid = middleOfThree(C.r, C.g, C.b);\n\n\tint minIndex, midIndex, maxIndex;\n\n\tif (Cmax > Cmin) {\n\t\tCmid = (((Cmid - Cmin) * s) / (Cmax - Cmin));\n\t\tCmax = s;\n\t} else {\n\t\tCmid = Cmax = 0.0;\n\t}\n\tCmin = 0.0;\n\n\tif (C.r < C.g) {\n\t\tif (C.r < C.b) {\n\t\t\tC.r = Cmin;\n\t\t\tif (C.g > C.b) {\n\t\t\t\tC.g = Cmax;\n\t\t\t\tC.b = Cmid;\n\t\t\t} else {\n\t\t\t\tC.g = Cmid;\n\t\t\t\tC.b = Cmax;\n\t\t\t}\n\t\t} else {\n\t\t\tC.r = Cmid;\n\t\t\tif (C.g < C.b) {\n\t\t\t\tC.g = Cmin;\n\t\t\t\tC.b = Cmax;\n\t\t\t} else {\n\t\t\t\tC.g = Cmax;\n\t\t\t\tC.b = Cmin;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (C.r < C.b) {\n\t\t\tC.r = Cmid;\n\t\t\tC.g = Cmin;\n\t\t\tC.b = Cmax;\n\t\t} else {\n\t\t\tif (C.g > C.b) {\n\t\t\t\tC.g = Cmid;\n\t\t\t\tC.b = Cmin;\n\t\t\t} else {\n\t\t\t\tC.g = Cmin;\n\t\t\t\tC.b = Cmid;\n\t\t\t}\n\t\t\tC.r = Cmax;\n\t\t}\n\t}\n\n\treturn C;\n}\n\nvoid main(void)\n{\n    %SPRITE_CODE%\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\n    vec4 target = texture2D(uSampler[1], vMapCoord);\n\n    //reverse hardlight\n    if (source.a == 0.0) {\n        gl_FragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    //yeah, premultiplied\n    vec3 Cs = source.rgb/source.a, Cb;\n    if (target.a > 0.0) {\n        Cb = target.rgb / target.a;\n\t}\n\t\n\t// Formula from https://drafts.fxtf.org/compositing/#blendingcolor\n\t// B(Cb, Cs) = SetLum(SetSat(Cs, Sat(Cb)), Lum(Cb))\n\n\tvec3 Cm = SetLum(SetSat(Cs, Sat(Cb)), Lum(Cb));\n\n\t\n    vec4 res;\n    res.xyz = (1.0 - source.a) * Cb + source.a * Cm;\n    res.a = source.a + target.a * (1.0-source.a);\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\n}\n`;\n\n    /**\n     * @class\n     * @extends PIXI.Shader\n     * @memberof PIXI.extras\n     * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n     * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\n     */\n    export class HueShader extends PictureShader {\n        constructor(gl: WebGLRenderingContext, tilingMode: number) {\n            super(gl, PictureShader.blendVert, overlayFrag, tilingMode);\n        }\n    }\n}\n\n\n","/// <reference path=\"PictureShader.ts\" />\n\nnamespace pixi_picture {\n\tconst overlayFrag = `\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler[2];\nuniform vec4 uColor;\n%SPRITE_UNIFORMS%\n\nvoid main(void)\n{\n    %SPRITE_CODE%\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\n    vec4 target = texture2D(uSampler[1], vMapCoord);\n\n    if (source.a == 0.0) {\n        gl_FragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    //yeah, premultiplied\n    vec3 Cs = source.rgb/source.a, Cb;\n    if (target.a > 0.0) {\n        Cb = target.rgb / target.a;\n\t}\n\t\n\tvec3 Cm = max(Cb, Cs);\n\t\n    vec4 res;\n    res.xyz = (1.0 - source.a) * Cb + source.a * Cm;\n    res.a = source.a + target.a * (1.0-source.a);\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\n}\n`;\n\n    /**\n     * @class\n     * @extends PIXI.Shader\n     * @memberof PIXI.extras\n     * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n     * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\n     */\n    export class LightenShader extends PictureShader {\n        constructor(gl: WebGLRenderingContext, tilingMode: number) {\n            super(gl, PictureShader.blendVert, overlayFrag, tilingMode);\n        }\n    }\n}\n","/// <reference path=\"PictureShader.ts\" />\n\nnamespace pixi_picture {\n\tconst overlayFrag = `\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler[2];\nuniform vec4 uColor;\n%SPRITE_UNIFORMS%\n\nvoid main(void)\n{\n    %SPRITE_CODE%\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\n    vec4 target = texture2D(uSampler[1], vMapCoord);\n\n    if (source.a == 0.0) {\n        gl_FragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    //yeah, premultiplied\n    vec3 Cs = source.rgb/source.a, Cb;\n    if (target.a > 0.0) {\n        Cb = target.rgb / target.a;\n\t}\n\t\n\t// Formula from here http://www.simplefilter.de/en/basics/mixmods.html\n\t// C = A + B - 1\n\tvec3 Cm = Cs + Cb - 1.0;\n\t\n\t\n\tvec4 res;\n    res.xyz = (1.0 - source.a) * Cb + source.a * Cm;\n    res.a = source.a + target.a * (1.0-source.a);\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\n}\n`;\n\n    /**\n     * @class\n     * @extends PIXI.Shader\n     * @memberof PIXI.extras\n     * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n     * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\n     */\n    export class LinearBurnShader extends PictureShader {\n        constructor(gl: WebGLRenderingContext, tilingMode: number) {\n            super(gl, PictureShader.blendVert, overlayFrag, tilingMode);\n        }\n    }\n}\n","/// <reference path=\"PictureShader.ts\" />\n\nnamespace pixi_picture {\n\tconst overlayFrag = `\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler[2];\nuniform vec4 uColor;\n%SPRITE_UNIFORMS%\n\nvoid main(void)\n{\n    %SPRITE_CODE%\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\n    vec4 target = texture2D(uSampler[1], vMapCoord);\n\n    if (source.a == 0.0) {\n        gl_FragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    //yeah, premultiplied\n    vec3 Cs = source.rgb/source.a, Cb;\n    if (target.a > 0.0) {\n        Cb = target.rgb / target.a;\n\t}\n\t\n\t// Formula from here http://www.simplefilter.de/en/basics/mixmods.html\n\t// C = A + B\n\tvec3 Cm = Cs + Cb;\n\t\n\t\n\tvec4 res;\n    res.xyz = (1.0 - source.a) * Cb + source.a * Cm;\n    res.a = source.a + target.a * (1.0-source.a);\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\n}\n`;\n\n    /**\n     * @class\n     * @extends PIXI.Shader\n     * @memberof PIXI.extras\n     * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n     * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\n     */\n    export class LinearDodgeShader extends PictureShader {\n        constructor(gl: WebGLRenderingContext, tilingMode: number) {\n            super(gl, PictureShader.blendVert, overlayFrag, tilingMode);\n        }\n    }\n}\n","/// <reference path=\"PictureShader.ts\" />\n\nnamespace pixi_picture {\n\tconst overlayFrag = `\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler[2];\nuniform vec4 uColor;\n%SPRITE_UNIFORMS%\n\nvoid main(void)\n{\n    %SPRITE_CODE%\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\n    vec4 target = texture2D(uSampler[1], vMapCoord);\n\n    if (source.a == 0.0) {\n        gl_FragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    //yeah, premultiplied\n    vec3 Cs = source.rgb/source.a, Cb;\n    if (target.a > 0.0) {\n        Cb = target.rgb / target.a;\n\t}\n\t\n\t// Formula from here http://www.simplefilter.de/en/basics/mixmods.html\n\t// C = B + 2*A - 1\n\tvec3 Cm = Cb + 2.0 * Cs - 1.0;\n\t\n\t\n\tvec4 res;\n    res.xyz = (1.0 - source.a) * Cb + source.a * Cm;\n    res.a = source.a + target.a * (1.0-source.a);\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\n}\n`;\n\n    /**\n     * @class\n     * @extends PIXI.Shader\n     * @memberof PIXI.extras\n     * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n     * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\n     */\n    export class LinearLightShader extends PictureShader {\n        constructor(gl: WebGLRenderingContext, tilingMode: number) {\n            super(gl, PictureShader.blendVert, overlayFrag, tilingMode);\n        }\n    }\n}\n","\t\n/// <reference path=\"PictureShader.ts\" />\n\nnamespace pixi_picture {\n\tconst overlayFrag = `\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler[2];\nuniform vec4 uColor;\n%SPRITE_UNIFORMS%\n\n// Functions from https://drafts.fxtf.org/compositing/#blendingcolor\nfloat Lum(vec3 C) {\n\tfloat lum = 0.3 * C.r + 0.59 * C.g + 0.11 * C.b;\n\treturn lum;\n}\n\n\nvec3 ClipColor(vec3 C) {\n\tfloat L = Lum(C);\n\tfloat n = min(C.r, min(C.g, C.b));\n\tfloat x = max(C.r, max(C.g, C.b));\n\tif (n < 0.0) {\n\t\tC = L + (((C - L) * L) / (L - n));\n\t}\n\tif(x > 1.0) {\n\t\tC = L + (((C - L) * (1.0 - L)) / (x - L));\n\t}\n\treturn C;\n}\n\nvec3 SetLum(vec3 C, float l) {\n\tfloat d = l - Lum(C);\n\tC.r = C.r + d;\n\tC.g = C.g + d;\n\tC.b = C.b + d;\n\treturn ClipColor(C);\n}\n\nvoid main(void)\n{\n    %SPRITE_CODE%\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\n    vec4 target = texture2D(uSampler[1], vMapCoord);\n\n    //reverse hardlight\n    if (source.a == 0.0) {\n        gl_FragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    //yeah, premultiplied\n    vec3 Cs = source.rgb/source.a, Cb;\n    if (target.a > 0.0) {\n        Cb = target.rgb / target.a;\n\t}\n\t\n\t// Formula from https://drafts.fxtf.org/compositing/#blendingcolor\n\t// SetLum(Cb, Lum(Cs))\n\n\tvec3 Cm = SetLum(Cb, Lum(Cs));\n\n\t\n    vec4 res;\n    res.xyz = (1.0 - source.a) * Cb + source.a * Cm;\n    res.a = source.a + target.a * (1.0-source.a);\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\n}\n`;\n\n    /**\n     * @class\n     * @extends PIXI.Shader\n     * @memberof PIXI.extras\n     * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n     * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\n     */\n    export class LuminosityShader extends PictureShader {\n        constructor(gl: WebGLRenderingContext, tilingMode: number) {\n            super(gl, PictureShader.blendVert, overlayFrag, tilingMode);\n        }\n    }\n}\n\n\n","namespace pixi_picture {\n    export function mapFilterBlendModesToPixi(gl: WebGLRenderingContext, array: Array<Array<PictureShader>> = []): Array<Array<PictureShader>>\n    {\n        PIXI.BLEND_MODES.LINEAR_DODGE = 20;\n        PIXI.BLEND_MODES.LINEAR_BURN = 21;\n        PIXI.BLEND_MODES.LINEAR_LIGHT = 22;\n        PIXI.BLEND_MODES.VIVID_LIGHT = 23;\n\n        //TODO - premultiply alpha would be different.\n        //add a boolean for that!\n        array[PIXI.BLEND_MODES.OVERLAY] = [new OverlayShader(gl, 0), new OverlayShader(gl, 1), new OverlayShader(gl, 2)];\n        array[PIXI.BLEND_MODES.HARD_LIGHT] = [new HardLightShader(gl, 0), new HardLightShader(gl, 1), new HardLightShader(gl, 2)];\n\t    array[PIXI.BLEND_MODES.SOFT_LIGHT] = [new SoftLightShader(gl, 0), new SoftLightShader(gl, 1), new SoftLightShader(gl, 2)];\n\t    array[PIXI.BLEND_MODES.DARKEN] = [new DarkenShader(gl, 0), new DarkenShader(gl, 1), new DarkenShader(gl, 2)];\n\t    array[PIXI.BLEND_MODES.LIGHTEN] = [new LightenShader(gl, 0), new LightenShader(gl, 1), new LightenShader(gl, 2)];\n\t    array[PIXI.BLEND_MODES.COLOR_DODGE] = [new ColorDodgeShader(gl, 0), new ColorDodgeShader(gl, 1), new ColorDodgeShader(gl, 2)];\n\t    array[PIXI.BLEND_MODES.COLOR_BURN] = [new ColorBurnShader(gl, 0), new ColorBurnShader(gl, 1), new ColorBurnShader(gl, 2)];\n        array[PIXI.BLEND_MODES.COLOR] = [new ColorShader(gl, 0), new ColorBurnShader(gl, 1), new ColorBurnShader(gl, 2)];\n\t    array[PIXI.BLEND_MODES.LUMINOSITY] = [new LuminosityShader(gl, 0), new LuminosityShader(gl, 1), new LuminosityShader(gl, 2)];\n\n        array[PIXI.BLEND_MODES.LINEAR_DODGE] = [new LinearDodgeShader(gl, 0), new LinearDodgeShader(gl, 1), new LinearDodgeShader(gl, 2)];\n\t    array[PIXI.BLEND_MODES.LINEAR_BURN] = [new LinearBurnShader(gl, 0), new LinearBurnShader(gl, 1), new LinearBurnShader(gl, 2)];\n\t    array[PIXI.BLEND_MODES.LINEAR_LIGHT] = [new LinearLightShader(gl, 0), new LinearLightShader(gl, 1), new LinearLightShader(gl, 2)];\n\n\t    array[PIXI.BLEND_MODES.HUE] = [new HueShader(gl, 0), new HueShader(gl, 1), new HueShader(gl, 2)];\n\t    array[PIXI.BLEND_MODES.SATURATION] = [new SaturationShader(gl, 0), new SaturationShader(gl, 1), new SaturationShader(gl, 2)];\n\t    array[PIXI.BLEND_MODES.DIFFERENCE] = [new DifferenceShader(gl, 0), new DifferenceShader(gl, 1), new DifferenceShader(gl, 2)];\n\t    array[PIXI.BLEND_MODES.VIVID_LIGHT] = [new VividLightShader(gl, 0), new VividLightShader(gl, 1), new VividLightShader(gl, 2)];\n\n        return array;\n    }\n}\n","namespace pixi_picture {\n\n    var normalFrag = `\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler[2];\nuniform vec4 uColor;\n%SPRITE_UNIFORMS%\n\nvoid main(void)\n{\n    %SPRITE_CODE%\n\n    vec4 sample = texture2D(uSampler[0], textureCoord);\n    gl_FragColor = sample * uColor;\n}\n`;\n\n    var normalVert = `\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n%SPRITE_UNIFORMS%\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    %SPRITE_CODE%\n}\n`;\n\n    export class NormalShader extends PictureShader {\n        /**\n         * @class\n         * @extends PIXI.Shader\n         * @memberof PIXI.extras\n         * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n         * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\n         */\n        constructor(gl: WebGLRenderingContext, tilingMode: number) {\n            super(gl, normalVert, normalFrag, tilingMode);\n        }\n    }\n}\n","namespace pixi_picture {\n    const overlayFrag = `\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler[2];\nuniform vec4 uColor;\n%SPRITE_UNIFORMS%\n\nvoid main(void)\n{\n    %SPRITE_CODE%\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\n    vec4 target = texture2D(uSampler[1], vMapCoord);\n\n    //reverse hardlight\n    if (source.a == 0.0) {\n        gl_FragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    //yeah, premultiplied\n    vec3 Cb = source.rgb/source.a, Cs;\n    if (target.a > 0.0) {\n        Cs = target.rgb / target.a;\n    }\n    vec3 multiply = Cb * Cs * 2.0;\n    vec3 Cb2 = Cb * 2.0 - 1.0;\n    vec3 screen = Cb2 + Cs - Cb2 * Cs;\n    vec3 B;\n    if (Cs.r <= 0.5) {\n        B.r = multiply.r;\n    } else {\n        B.r = screen.r;\n    }\n    if (Cs.g <= 0.5) {\n        B.g = multiply.g;\n    } else {\n        B.g = screen.g;\n    }\n    if (Cs.b <= 0.5) {\n        B.b = multiply.b;\n    } else {\n        B.b = screen.b;\n    }\n    vec4 res;\n    res.xyz = (1.0 - source.a) * Cs + source.a * B;\n    res.a = source.a + target.a * (1.0-source.a);\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\n}\n`;\n\n    /**\n     * @class\n     * @extends PIXI.Shader\n     * @memberof PIXI.extras\n     * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n     * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\n     */\n    export class OverlayShader extends PictureShader {\n        constructor(gl: WebGLRenderingContext, tilingMode: number) {\n            super(gl, PictureShader.blendVert, overlayFrag, tilingMode);\n        }\n    }\n}\n","namespace pixi_picture {\n    import Matrix = PIXI.Matrix;\n    import Sprite = PIXI.Sprite;\n\timport Texture = PIXI.Texture;\n    import TextureUvs = PIXI.TextureUvs;\n    import TilingSprite = PIXI.extras.TilingSprite;\n    import WRAP_MODES = PIXI.WRAP_MODES;\n\n    function nextPow2(v: number): number {\n        v += (v === 0)?1:0;\n        --v;\n        v |= v >>> 1;\n        v |= v >>> 2;\n        v |= v >>> 4;\n        v |= v >>> 8;\n        v |= v >>> 16;\n        return v + 1;\n    }\n\n    export class PictureRenderer extends PIXI.ObjectRenderer {\n        constructor(renderer: PIXI.WebGLRenderer) {\n            super(renderer);\n        }\n\n        drawModes: Array<Array<PictureShader>>;\n        normalShader: Array<PictureShader>;\n        _tempClamp: Float32Array;\n        _tempColor: Float32Array;\n        _tempRect: PIXI.Rectangle;\n        _tempRect2: PIXI.Rectangle;\n        _tempRect3: PIXI.Rectangle;\n        _tempMatrix: PIXI.Matrix;\n        _tempMatrix2: PIXI.Matrix;\n        _bigBuf: Uint8Array;\n        _renderTexture: PIXI.BaseRenderTexture;\n\n        onContextChange() {\n\t        filterManagerMixin(this.renderer.filterManager);\n\n            const gl = this.renderer.gl;\n\n            this.drawModes = mapFilterBlendModesToPixi(gl);\n            this.normalShader = [new NormalShader(gl, 0), new NormalShader(gl, 1), new NormalShader(gl, 2)];\n            this._tempClamp = new Float32Array(4);\n            this._tempColor = new Float32Array(4);\n            this._tempRect = new PIXI.Rectangle();\n            this._tempRect2 = new PIXI.Rectangle();\n            this._tempRect3 = new PIXI.Rectangle();\n            this._tempMatrix = new PIXI.Matrix();\n            this._tempMatrix2 = new PIXI.Matrix();\n            this._bigBuf = new Uint8Array(1 << 20);\n            this._renderTexture = new PIXI.BaseRenderTexture(1024, 1024);\n        }\n\n        start() {\n\n        }\n\n        flush() {\n\n        }\n\n        _getRenderTexture(minWidth: number, minHeight: number) {\n            if (this._renderTexture.width < minWidth ||\n                this._renderTexture.height < minHeight) {\n                minWidth = nextPow2(minWidth);\n                minHeight = nextPow2(minHeight);\n                this._renderTexture.resize(minWidth, minHeight);\n            }\n            return this._renderTexture;\n        }\n\n        _getBuf(size: number): Float32Array {\n            let buf = this._bigBuf;\n            if (buf.length < size) {\n                size = nextPow2(size);\n                buf = new Uint8Array(size);\n                this._bigBuf = buf;\n            }\n            return buf;\n        }\n\n        render(sprite: Sprite) {\n            if (!sprite.texture.valid) {\n                return;\n            }\n            let tilingMode = 0;\n            if ((sprite as any).tileTransform) {\n                //for Sprite\n                tilingMode = this._isSimpleSprite(sprite) ? 1 : 2;\n            }\n\n            const blendShader = this.drawModes[sprite.blendMode];\n            if (blendShader) {\n                this._renderBlend(sprite, blendShader[tilingMode]);\n            } else {\n                this._renderNormal(sprite, this.normalShader[tilingMode]);\n            }\n        }\n\n        _renderNormal(sprite: Sprite, shader: PictureShader) {\n            const renderer = this.renderer;\n            renderer.bindShader(shader);\n            renderer.state.setBlendMode(sprite.blendMode);\n            this._renderInner(sprite, shader);\n        }\n\n        _renderBlend(sprite: Sprite, shader: PictureShader) {\n            //nothing there yet\n            const renderer = this.renderer;\n            const spriteBounds = sprite.getBounds();\n            const renderTarget = renderer._activeRenderTarget;\n            const matrix = renderTarget.projectionMatrix;\n            const flipX = matrix.a < 0;\n            const flipY = matrix.d < 0;\n            const resolution = renderTarget.resolution;\n            const screen = this._tempRect;\n            const fr = renderTarget.sourceFrame || renderTarget.destinationFrame;\n            screen.x = 0;\n            screen.y = 0;\n            screen.width = fr.width;\n            screen.height = fr.height;\n\n            const bounds = this._tempRect2;\n            const fbw = fr.width * resolution, fbh = fr.height * resolution;\n            bounds.x = (spriteBounds.x + matrix.tx / matrix.a) * resolution + fbw / 2;\n            bounds.y = (spriteBounds.y + matrix.ty / matrix.d) * resolution + fbh / 2;\n            bounds.width = spriteBounds.width * resolution;\n            bounds.height = spriteBounds.height * resolution;\n            if (flipX) {\n                bounds.y = fbw - bounds.width - bounds.x;\n            }\n            if (flipY) {\n                bounds.y = fbh - bounds.height - bounds.y;\n            }\n\n            const screenBounds = this._tempRect3;\n            const x_1 = Math.floor(Math.max(screen.x, bounds.x));\n            const x_2 = Math.ceil(Math.min(screen.x + screen.width, bounds.x + bounds.width));\n            const y_1 = Math.floor(Math.max(screen.y, bounds.y));\n            const y_2 = Math.ceil(Math.min(screen.y + screen.height, bounds.y + bounds.height));\n            const pixelsWidth = x_2 - x_1;\n            const pixelsHeight = y_2 - y_1;\n            if (pixelsWidth <= 0 || pixelsHeight <= 0) {\n                //culling\n                return;\n            }\n            //TODO: padding\n            const rt = this._getRenderTexture(pixelsWidth, pixelsHeight);\n            renderer.bindTexture(rt, 1, true);\n            const gl = renderer.gl;\n            if (renderer.renderingToScreen && renderTarget.root) {\n                const buf = this._getBuf(pixelsWidth * pixelsHeight * 4);\n                gl.readPixels(x_1, y_1, pixelsWidth, pixelsHeight, gl.RGBA, gl.UNSIGNED_BYTE, this._bigBuf);\n                //REVERT Y?\n                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, pixelsWidth, pixelsHeight, gl.RGBA, gl.UNSIGNED_BYTE, this._bigBuf);\n            } else {\n                gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x_1, y_1, pixelsWidth, pixelsHeight);\n            }\n\n            renderer.bindShader(shader);\n            renderer.state.setBlendMode(PIXI.BLEND_MODES.NORMAL);\n            if (shader.uniforms.mapMatrix) {\n                const mapMatrix = this._tempMatrix;\n                mapMatrix.a = bounds.width / rt.width / spriteBounds.width;\n                if (flipX) {\n                    mapMatrix.a = -mapMatrix.a;\n                    mapMatrix.tx = (bounds.x - x_1) / rt.width - (spriteBounds.x + spriteBounds.width) * mapMatrix.a;\n                } else {\n                    mapMatrix.tx = (bounds.x - x_1) / rt.width - spriteBounds.x * mapMatrix.a;\n                }\n                mapMatrix.d = bounds.height / rt.height / spriteBounds.height;\n                if (flipY) {\n                    mapMatrix.d = -mapMatrix.d;\n                    mapMatrix.ty = (bounds.y - y_1) / rt.height - (spriteBounds.y + spriteBounds.height) * mapMatrix.d;\n                } else {\n                    mapMatrix.ty = (bounds.y - y_1) / rt.height - spriteBounds.y * mapMatrix.d;\n                }\n\n                shader.uniforms.mapMatrix = mapMatrix.toArray(true);\n            }\n\n            this._renderInner(sprite, shader);\n        }\n\n        _renderInner(sprite: Sprite, shader: PictureShader) {\n            const renderer = this.renderer;\n            if (shader.tilingMode > 0) {\n                this._renderWithShader(sprite as TilingSprite, shader.tilingMode === 1, shader);\n            } else {\n                this._renderSprite(sprite, shader);\n            }\n        }\n\n        _renderWithShader(ts: TilingSprite, isSimple: boolean, shader: PictureShader) {\n            const quad = shader.tempQuad;\n            const renderer = this.renderer;\n            renderer.bindVao(quad.vao);\n            let vertices = quad.vertices;\n\n            const _width: number = (ts as any)._width;\n            const _height: number = (ts as any)._height;\n            const _anchorX: number = (ts as any)._anchor._x;\n            const _anchorY: number = (ts as any)._anchor._y;\n\n            const w0 = _width * (1 - _anchorX);\n            const w1 = _width * -_anchorX;\n\n            const h0 = _height * (1 - _anchorY);\n            const h1 = _height * -_anchorY;\n\n            const wt = ts.transform.worldTransform;\n\n            const a = wt.a;\n            const b = wt.b;\n            const c = wt.c;\n            const d = wt.d;\n            const tx = wt.tx;\n            const ty = wt.ty;\n\n            vertices[0] = (a * w1) + (c * h1) + tx;\n            vertices[1] = (d * h1) + (b * w1) + ty;\n\n            vertices[2] = (a * w0) + (c * h1) + tx;\n            vertices[3] = (d * h1) + (b * w0) + ty;\n\n            vertices[4] = (a * w0) + (c * h0) + tx;\n            vertices[5] = (d * h0) + (b * w0) + ty;\n\n            vertices[6] = (a * w1) + (c * h0) + tx;\n            vertices[7] = (d * h0) + (b * w1) + ty;\n\n            vertices = quad.uvs;\n\n            vertices[0] = vertices[6] = -ts.anchor.x;\n            vertices[1] = vertices[3] = -ts.anchor.y;\n\n            vertices[2] = vertices[4] = 1.0 - ts.anchor.x;\n            vertices[5] = vertices[7] = 1.0 - ts.anchor.y;\n\n            quad.upload();\n\n            const tex = (ts as any)._texture;\n            const lt = ts.tileTransform.localTransform;\n            const uv = ts.uvTransform;\n            const mapCoord : Matrix = (uv as any).mapCoord;\n            const uClampFrame : Float32Array = (uv as any).uClampFrame;\n            const uClampOffset : Float32Array = (uv as any).uClampOffset;\n\n            const w = tex.width;\n            const h = tex.height;\n            const W = _width;\n            const H = _height;\n\n            const tempMat = this._tempMatrix2;\n\n            tempMat.set(lt.a * w / W,\n                lt.b * w / H,\n                lt.c * h / W,\n                lt.d * h / H,\n                lt.tx / W,\n                lt.ty / H);\n\n            // that part is the same as above:\n            // tempMat.identity();\n            // tempMat.scale(tex.width, tex.height);\n            // tempMat.prepend(lt);\n            // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);\n\n            tempMat.invert();\n            if (isSimple) {\n                tempMat.append(mapCoord);\n            }\n            else {\n                shader.uniforms.uMapCoord = mapCoord.toArray(true);\n                shader.uniforms.uClampFrame = uClampFrame;\n                shader.uniforms.uClampOffset = uClampOffset;\n            }\n            shader.uniforms.uTransform = tempMat.toArray(true);\n\n            const color = this._tempColor;\n            const alpha = ts.worldAlpha;\n\n            PIXI.utils.hex2rgb(ts.tint, color as any);\n            color[0] *= alpha;\n            color[1] *= alpha;\n            color[2] *= alpha;\n            color[3] = alpha;\n            shader.uniforms.uColor = color;\n\n            renderer.bindTexture(tex, 0, true);\n            quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);\n        }\n\n        _renderSprite(sprite: Sprite, shader: PictureShader) {\n            const renderer = this.renderer;\n            const quad = shader.tempQuad;\n            renderer.bindVao(quad.vao);\n            const uvs : TextureUvs = (sprite.texture as any)._uvs;\n\n            //sprite already has calculated the vertices. lets transfer them to quad\n\n            const vertices = quad.vertices;\n            const vd : Float32Array = sprite.vertexData;\n            for (let i = 0; i < 8; i++) {\n                quad.vertices[i] = vd[i];\n            }\n\n            //SpriteRenderer works differently, with uint32 UVS\n            //but for our demo float uvs are just fine\n            quad.uvs[0] = uvs.x0;\n            quad.uvs[1] = uvs.y0;\n            quad.uvs[2] = uvs.x1;\n            quad.uvs[3] = uvs.y1;\n            quad.uvs[4] = uvs.x2;\n            quad.uvs[5] = uvs.y2;\n            quad.uvs[6] = uvs.x3;\n            quad.uvs[7] = uvs.y3;\n\n            //TODO: add baricentric coords here\n            quad.upload();\n\n            const frame = sprite.texture.frame;\n            const base = sprite.texture.baseTexture;\n            const clamp = this._tempClamp;\n            //clamping 0.5 pixel from each side to reduce border artifact\n            //this is our plugin main purpose\n            const eps = 0.5 / base.resolution;\n            clamp[0] = (frame.x + eps) / base.width;\n            clamp[1] = (frame.y + eps) / base.height;\n            clamp[2] = (frame.x + frame.width - eps) / base.width;\n            clamp[3] = (frame.y + frame.height - eps) / base.height;\n            //take a notice that size in pixels is realWidth,realHeight\n            //width and height are divided by resolution\n            shader.uniforms.uTextureClamp = clamp;\n\n            const color = this._tempColor;\n            PIXI.utils.hex2rgb(sprite.tint, color as any);\n            const alpha = sprite.worldAlpha;\n            //premultiplied alpha tint\n            //of course we could do that in shader too\n            color[0] *= alpha;\n            color[1] *= alpha;\n            color[2] *= alpha;\n            color[3] = alpha;\n            shader.uniforms.uColor = color;\n\n            //bind texture to unit 0, our default sampler unit\n            renderer.bindTexture(base, 0, true);\n            quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);\n        }\n\n        _isSimpleSprite(ts: Sprite): boolean {\n            const renderer = this.renderer;\n            const tex : Texture = (ts as any)._texture;\n            const baseTex = tex.baseTexture;\n            let isSimple = (baseTex as any).isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n\n            // auto, force repeat wrapMode for big tiling textures\n            if (isSimple) {\n                if (!(baseTex as any)._glTextures[renderer.CONTEXT_UID]) {\n                    if (baseTex.wrapMode === WRAP_MODES.CLAMP) {\n                        baseTex.wrapMode = WRAP_MODES.REPEAT;\n                    }\n                }\n                else {\n                    isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;\n                }\n            }\n\n            return isSimple;\n        }\n    }\n\n    PIXI.WebGLRenderer.registerPlugin('picture', PictureRenderer);\n    PIXI.CanvasRenderer.registerPlugin('picture', PIXI.CanvasSpriteRenderer as any);\n}\n","\t\n/// <reference path=\"PictureShader.ts\" />\n\nnamespace pixi_picture {\n\tconst overlayFrag = `\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler[2];\nuniform vec4 uColor;\n%SPRITE_UNIFORMS%\n\n// Functions from https://drafts.fxtf.org/compositing/#blendingcolor\nfloat Lum(vec3 C) {\n\tfloat lum = 0.3 * C.r + 0.59 * C.g + 0.11 * C.b;\n\treturn lum;\n}\n\n\nvec3 ClipColor(vec3 C) {\n\tfloat L = Lum(C);\n\tfloat n = min(C.r, min(C.g, C.b));\n\tfloat x = max(C.r, max(C.g, C.b));\n\tif (n < 0.0) {\n\t\tC = L + (((C - L) * L) / (L - n));\n\t}\n\tif(x > 1.0) {\n\t\tC = L + (((C - L) * (1.0 - L)) / (x - L));\n\t}\n\treturn C;\n}\n\nvec3 SetLum(vec3 C, float l) {\n\tfloat d = l - Lum(C);\n\tC.r = C.r + d;\n\tC.g = C.g + d;\n\tC.b = C.b + d;\n\treturn ClipColor(C);\n}\n\nfloat Sat(vec3 C) {\n\treturn (max(C.r, max(C.g, C.b)) - min(C.r, min(C.g, C.b)));\n}\n\n// Find middle number of 3 numbers\nfloat middleOfThree(float a, float b, float c)\n{\n    if (a > b)\n    {\n\t\tif (b > c) {\n            return b;\n\t\t} else if (a > c) {\n            return c;\n\t\t} else {\n            return a;\n\t\t}\n    }\n    else\n    {\n\t\tif (a > c) {\n            return a;\n\t\t} else if (b > c) {\n            return c;\n\t\t} else {\n            return b;\n\t\t}\n    }\n}\n\nvec3 SetSat(vec3 C, float s) {\n\tfloat Cmax = max(C.r, max(C.g, C.b));\n\tfloat Cmin = min(C.r, min(C.g, C.b));\n\tfloat Cmid = middleOfThree(C.r, C.g, C.b);\n\n\tint minIndex, midIndex, maxIndex;\n\n\tif (Cmax > Cmin) {\n\t\tCmid = (((Cmid - Cmin) * s) / (Cmax - Cmin));\n\t\tCmax = s;\n\t} else {\n\t\tCmid = Cmax = 0.0;\n\t}\n\tCmin = 0.0;\n\n\tif (C.r < C.g) {\n\t\tif (C.r < C.b) {\n\t\t\tC.r = Cmin;\n\t\t\tif (C.g > C.b) {\n\t\t\t\tC.g = Cmax;\n\t\t\t\tC.b = Cmid;\n\t\t\t} else {\n\t\t\t\tC.g = Cmid;\n\t\t\t\tC.b = Cmax;\n\t\t\t}\n\t\t} else {\n\t\t\tC.r = Cmid;\n\t\t\tif (C.g < C.b) {\n\t\t\t\tC.g = Cmin;\n\t\t\t\tC.b = Cmax;\n\t\t\t} else {\n\t\t\t\tC.g = Cmax;\n\t\t\t\tC.b = Cmin;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (C.r < C.b) {\n\t\t\tC.r = Cmid;\n\t\t\tC.g = Cmin;\n\t\t\tC.b = Cmax;\n\t\t} else {\n\t\t\tif (C.g > C.b) {\n\t\t\t\tC.g = Cmid;\n\t\t\t\tC.b = Cmin;\n\t\t\t} else {\n\t\t\t\tC.g = Cmin;\n\t\t\t\tC.b = Cmid;\n\t\t\t}\n\t\t\tC.r = Cmax;\n\t\t}\n\t}\n\n\treturn C;\n}\n\nvoid main(void)\n{\n    %SPRITE_CODE%\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\n    vec4 target = texture2D(uSampler[1], vMapCoord);\n\n    //reverse hardlight\n    if (source.a == 0.0) {\n        gl_FragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    //yeah, premultiplied\n    vec3 Cs = source.rgb/source.a, Cb;\n    if (target.a > 0.0) {\n        Cb = target.rgb / target.a;\n\t}\n\t\n\t// Formula from https://drafts.fxtf.org/compositing/#blendingcolor\n\t// B(Cb, Cs) = SetLum(SetSat(Cb, Sat(Cs)), Lum(Cb))\n\n\tvec3 Cm = SetLum(SetSat(Cb, Sat(Cs)), Lum(Cb));\n\n\t\n    vec4 res;\n    res.xyz = (1.0 - source.a) * Cb + source.a * Cm;\n    res.a = source.a + target.a * (1.0-source.a);\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\n}\n`;\n\n    /**\n     * @class\n     * @extends PIXI.Shader\n     * @memberof PIXI.extras\n     * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n     * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\n     */\n    export class SaturationShader extends PictureShader {\n        constructor(gl: WebGLRenderingContext, tilingMode: number) {\n            super(gl, PictureShader.blendVert, overlayFrag, tilingMode);\n        }\n    }\n}\n\n\n","namespace pixi_picture {\n    const softLightFrag = `\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\nvarying vec4 vColor;\n \nuniform sampler2D uSampler[2];\nuniform vec4 uColor;\n%SPRITE_UNIFORMS%\n\nvoid main(void)\n{\n    %SPRITE_CODE%\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\n    vec4 target = texture2D(uSampler[1], vMapCoord);\n\n    if (source.a == 0.0) {\n        gl_FragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    vec3 Cs = source.rgb/source.a, Cb;\n    if (target.a > 0.0) {\n        Cb = target.rgb / target.a;\n\t}\n    \n    vec3 first = Cb - (1.0 - 2.0 * Cs) * Cb * (1.0 - Cb);\n\n    vec3 B;\n    vec3 D;\n    if (Cs.r <= 0.5)\n    {\n        B.r = first.r;\n    }\n    else\n    {\n        if (Cb.r <= 0.25)\n        {\n            D.r = ((16.0 * Cb.r - 12.0) * Cb.r + 4.0) * Cb.r;    \n        }\n        else\n        {\n            D.r = sqrt(Cb.r);\n        }\n        B.r = Cb.r + (2.0 * Cs.r - 1.0) * (D.r - Cb.r);\n    }\n    if (Cs.g <= 0.5)\n    {\n        B.g = first.g;\n    }\n    else\n    {\n        if (Cb.g <= 0.25)\n        {\n            D.g = ((16.0 * Cb.g - 12.0) * Cb.g + 4.0) * Cb.g;    \n        }\n        else\n        {\n            D.g = sqrt(Cb.g);\n        }\n        B.g = Cb.g + (2.0 * Cs.g - 1.0) * (D.g - Cb.g);\n    }\n    if (Cs.b <= 0.5)\n    {\n        B.b = first.b;\n    }\n    else\n    {\n        if (Cb.b <= 0.25)\n        {\n            D.b = ((16.0 * Cb.b - 12.0) * Cb.b + 4.0) * Cb.b;    \n        }\n        else\n        {\n            D.b = sqrt(Cb.b);\n        }\n        B.b = Cb.b + (2.0 * Cs.b - 1.0) * (D.b - Cb.b);\n    }   \n\n    vec4 res;\n\n    res.xyz = (1.0 - source.a) * Cb + source.a * B;\n    res.a = source.a + target.a * (1.0-source.a);\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\n}\n`;\n\n    /**\n     * @class\n     * @extends PIXI.Shader\n     * @memberof PIXI.extras\n     * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n     * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\n     */\n    export class SoftLightShader extends PictureShader {\n        constructor(gl: WebGLRenderingContext, tilingMode: number) {\n            super(gl, PictureShader.blendVert, softLightFrag, tilingMode);\n        }\n    }\n}\n","namespace pixi_picture {\n    export class Sprite extends PIXI.Sprite {\n        constructor(texture: PIXI.Texture) {\n            super(texture);\n            this.pluginName = 'picture'\n        }\n    }\n}\n","namespace pixi_picture {\n    export class TilingSprite extends PIXI.extras.TilingSprite {\n        constructor(texture: PIXI.Texture) {\n            super(texture);\n            this.pluginName = 'picture'\n        }\n    }\n}\n","/// <reference path=\"PictureShader.ts\" />\n\nnamespace pixi_picture {\n\tconst vivdLightFrag = `\nvarying vec2 vTextureCoord;\nvarying vec2 vMapCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler[2];\nuniform vec4 uColor;\n%SPRITE_UNIFORMS%\n\nfloat flip(float v) {\n  return 1.0-v;\n}\n\nfloat saturate(float v) {\n  return clamp(v,0.0,1.0);\n}\n\nfloat ps(float D, float S) {\n    if(S < 0.5) {\n        if(S==0.0) return 0.0;\n        return flip( saturate( flip(D) / (2.0*S) ) );\n    } else {\n        if(S==1.0) return 1.0;\n        return saturate( D/(flip(2.0*(S-0.5)) ) );\n    }\n}\n\nvec4 normal_blend(vec4 a, vec4 b) {\n\n  if(a.a==0.0) {\n    return b;\n  }\n\n  float alpha=a.a+b.a-a.a*b.a;\n  vec3 c = (a.a*a.rgb+b.a*b.rgb*(1.0-a.a))/alpha;\n  return vec4(c.r,c.g,c.b,alpha);\n}\n\n\n\n// // this is the most commonly listed formula on the web.\n// // as best as i can tell, it's simply wrong.\n// float pixmath(float blend, float base) {\n//     if(blend>0.5) {\n//         return 1.0 - saturate((1.0-base)/(2.0*(blend-0.5)));\n//     } else {\n//         return saturate(base/(1.0-2.0*blend));\n//     }\n// }\n//\n// // this is a formula from the obscure website:\n// // http://www.simplefilter.de/en/basics/mixmods.html\n// // it appears to work.\n// float simpel(float A, float B) {\n//     if(A <= 0.5) {\n//         return 1.0 - saturate( (1.0-B)/(2.0*A) );\n//     } else {\n//         return saturate(B/(2.0*(1.0-A)));\n//     }\n// }\n\nvoid main(void)\n{\n    %SPRITE_CODE%\n    vec4 source = texture2D(uSampler[0], textureCoord) * uColor;\n    vec4 target = texture2D(uSampler[1], vMapCoord);\n\n    if (source.a == 0.0) {\n        gl_FragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    // unpremultiply\n    vec3 Cs = source.rgb/source.a, Cb;\n    if (target.a > 0.0) {\n        Cb = target.rgb / target.a;\n\t}\n\t\n\t\n    vec4 r=vec4( ps(Cs.r, Cb.r), ps(Cs.g, Cb.g), ps(Cs.b, Cb.b), source.a);\n\tvec4 b = vec4(Cb, target.a);\n    vec4 Cm=normal_blend(r, b);\n\n\n\n\n\t\n\t\n\tvec4 res;\n    res.xyz = (1.0 - source.a) * Cb + source.a * Cm.rgb;\n    res.a = source.a + target.a * (1.0-source.a);\n    gl_FragColor = vec4(res.xyz * res.a, res.a);\n}\n`;\n\n    /**\n     * @class\n     * @extends PIXI.Shader\n     * @memberof PIXI.extras\n     * @param gl {PIXI.Shader} The WebGL shader manager this shader works for.\n     * @param tilingMode {number} 0 for default, 1 for simple tiling, 2 for tiling\n     */\n    export class VividLightShader extends PictureShader {\n        constructor(gl: WebGLRenderingContext, tilingMode: number) {\n            super(gl, PictureShader.blendVert, vivdLightFrag, tilingMode);\n        }\n    }\n}\n","/// <reference types=\"pixi.js\" />\nnamespace pixi_picture {\n\t(PIXI as any).picture = pixi_picture;\n}\n"]}